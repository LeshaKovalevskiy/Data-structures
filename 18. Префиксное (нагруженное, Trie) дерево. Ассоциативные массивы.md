## Префиксное (нагруженное, Trie) дерево. Ассоциативные массивы

Cтруктура данных, которая использует такие деревья в своей работе – ассоциативные массивы.

Доступ к данным осуществляется по ключам (как правило, строкам), а не по индексам (порядковым номерам). В качестве ключей может быть использована любая байтовая
последовательность символов.

Предположим, что у нас имеется следующий ассоциативный массив с наборами ключ-значение:

```c++
ar["do"] = 1;
ar["to"] = 2;
ar["dog"] = 3;
ar["dr"] = 4;
```

Для создания связей между ключами `"do"`, `"to"`, `"dog"`, `"dr"` и соответствующими значениями формируется префиксное дерево, которое будет иметь вид:

![image](https://user-images.githubusercontent.com/124737857/230771406-9d89e035-e0c9-460c-a142-129ca406c568.png)

Здесь в каждом узле хранится ровно один символ ключа (кроме корневого узла, который не хранит никакого символа и является попросту отправной точкой). У корня два
потомка, так как ключи в нашем примере могут начинаться или с символа `d` или с символа `t`. Далее, узел `d` также имеет два потомка, так как после символа `d` может
идти или символ `o` или символ `r`. А узел `t` имеет только одного потомка, т.к. у нас определен только один ключ `«to»`, то есть, после `t` может идти только символ
`o`. По тому же принципу узел `o` имеет одного потомка с символом `g`.

Каждый узел префиксного дерева содержит два поля: `is_key` и `data`. Поле `is_key`, которое принимает булевы значения `true` и `false`, отмечает, является ли данная
вершина дерева ключом ассоциативного массива или же просто промежуточной вершиной. Например, символы `d` и `t` отмечены как `false`. Значит, они не образуют
самостоятельных ключей. Именно поэтому, если в программе будет идти обращение к ключу:

```c++
int val = ar["d"];
```

то мы получим некоторое предопределенное значение для несуществующего ключа. 

А вот если написать:

```c++
int val = ar["do"];
```

то переменная `val` будет равна 1, потому что узел с символом `o` имеет значение `true` поля `is_key`.

Второе поле `data` просто содержит данные, связанные с тем или иным ключом. Причем, данные можно сохранять только в тех вершинах, у которых `is_key` равен `true`.

## Алгоритм формирования префиксного дерева

Предположим, создаются четыре пары ключ-значение:

```python
ar["dog"] = 1;
ar["to"] = 2;
ar["dos"] = 3;
ar["mul"] = 4;
```

![image](https://user-images.githubusercontent.com/124737857/230772056-1263cb3c-ac38-4d61-a108-02be4cc68fda.png)

Изначально, префиксное дерево имеет только корневую вершину без каких-либо символов. Первый ключ, который в него добавляется – это строка `«dog»`. Очевидно, нам
последовательно нужно сформировать три вершины, которые следуют друг за другом. Причем вершины `d` и `o` имеют флаг `is_key = false`, а последняя вершина `g` – 
значение `is_key = true`, т.к. она хранит непосредственно данные для ключа `«dog»`. По аналогии добавляются вершины для ключа `«to»`. Следующий ключ `«dos»`. Вершины
`d` и `o` уже имеются в префиксном дереве, поэтому достаточно добавить еще одну вершину `s`, как дочернюю от вершины `o`. Вершину `s` помечаем `is_key=true` и
сохраняем данные `data=3`. Последний ключ `«mul»` добавляется по тем же правилам.

Объем вычислений для добавления нового ключа с точки зрения O большого, равно `O(|key|)`, где `|key|` - длина (число символов) ключа.

## Алгоритм поиска ключа в префиксном дереве

Предположим, у нас имеется ранее сформированное префиксное дерево. И мы хотим взять из массива значение по некоторому ключу, например, `«dos»`:

```c++
val = ar["dos"]
```

В этом случае выбирается первый символ ключа – это `«d»` и в дереве среди потомков корневой вершины ищется вершина с этим символом. Она у нас есть, поэтому указатель
`p` переходит к этой вершине (ссылается на эту вершину). Следующий символ в ключе – это `«o»`. Поэтому среди потомков вершины `d` ищется вершина с символом `«o»`. Она
также присутствует в дереве и указатель `p` переходит к ней. Наконец, последний символ ключа – это `«s»`. Среди дочерних вершин узла o ищется вершина с символом `«s»`.
И указатель перемещается на нее. Далее проверяется, если эта вершина является ключевой, а не промежуточной, то есть флаг `is_key=true`, значит, ключ `«dos»` в нашем
префиксном дереве присутствует и мы возвращаем данные, которые хранятся в поле `data`, то есть, значение 3.

Теперь предположим, что мы хотим обратиться в ассоциативном массиве по ключу `«do»`:

```c++
val = ar["do"]
```

Также начинаем движение от корня дерева. Переходим сначала к узлу `«d»`, затем, к узлу `«o»`. Этот узел присутствует в дереве, но значение поля `is_key=false`, то
есть, узел `«o»` промежуточный, а не конечный для какого-либо ключа. Это значит, что ключа `«do»` в нашем префиксном дереве нет. И тогда, можно вернуть некоторое
значение по умолчанию, которое соответствует отсутствующему ключу.

Другой случай, когда нам нужно найти ключ, например, `«till»`:

```c++
val = ar["till"]
```

Также начинаем с корня и переходим к узлу `t`. Далее, у этого узла ищем потомка с символом `«i»`. Но его нет. Следовательно, ключ `«till»` в нашем префиксном дереве
отсутствует.

Временная сложность алгоритма поиска ключа равна `O(|key|)`.

## Алгоритм удаления ключа из префиксного дерева

Давайте теперь представим, что нам нужно удалить какой-либо ключ из ассоциативного массива (префиксного дерева). Пусть имеется следующее нагруженное дерево:

![image](https://user-images.githubusercontent.com/124737857/230772403-b953ce0b-fecf-4207-ba0c-c1a497a65368.png)

Здесь представлены следующие ключи: `«do»`, `«dog»`, `«dos»`, `«to»`, `«mul»`. Сначала мы выполним удаление ключа `«do»`. Из структуры дерева видно, что узел `o`
является промежуточным для узлов `g` и `s`. Поэтому его и нужно пометить промежуточным для алгоритма поиска ключей, то есть флаг `is_key` приравнять `false`. Все,
теперь в дереве нет ключа `«do»`.

Другой пример удаления ключа `«mul»`. За него отвечают три последовательных узла `m`, `u`, `l`. Узел `l` – листовой (у него нет потомков). Поэтому здесь есть два
варианта удаления. Первый, это также пометить узел `l` не ключевым, то есть `is_key=false`. Во втором варианте, исключить из дерева все листовые вершины, связанные с
ключом `«mul»`. Удаление происходит с последнего узла `l`. После этого узел `u` становится листовым, значит, его также можно удалить. Наконец, узел `m`, тоже листовой,
удаляется из префиксного дерева. В результате мы удалили все три узла, связанных только с этим одним ключом `«mul»`.

Какой же алгоритм удаления ключей использовать? Обычно, это вытекает из конкретной практической задачи. Если ожидается построение больших нагруженных деревьев, то
считается достаточным изменение флага `is_key` на значение `false`. К большой потери памяти это не приведет, но несколько ускорит работу алгоритма удаления. Если же
дерево небольшое, то целесообразно физически удалять ненужные вершины.

Вообще, с помощью последовательного удаления листовых вершин, которые не связаны ни с одним ключом, можно выполнять сжатие префиксного дерева. Это можно использовать,
как отдельный алгоритм для оптимизации нагруженного дерева. И вызывать его не каждый раз при удалении ключа, а после удаления определенного количества ключей
ассоциативного массива.

Временная сложность алгоритма удаления ключа равна `O(|key|)`.

## Заключение

Вообще нагруженные деревья часто эффективнее по памяти, чем хэш-таблицы. Это связано с тем, что у множества ключей в нагруженном дереве совпадают префиксы. Например,
для ключей `«dog»`, `«dos»` единый префикс `«do»`, то есть, используется одна и та же пара вершин `d` и `o` для этих двух строк. Если в последующем будут добавлены новые ключи
с тем же префиксом, например `«dota»`, `«doka»` и т.п., то будут использованы уже существующие вершины и добавлены новые.

Отсюда же хорошо видно, почему такие деревья получили название префиксное. Мы можем для любой начальной последовательности символов (префиксу) получить наборы ключей
(слов), которые ему соответствуют. Например, в нашем примере дерева по префиксу `«do»` можно выделить два ключа: `«dog»` и `«dos»`. Или, по префиксу `«d»` - три ключа: `«do»`,
`«dog»` и `«dos»`. И эта процедура выполняется достаточно быстро – быстрее, чем при других способах организации данных. Именно поэтому префиксные деревья были положены в
основу первых алгоритмов подсказки слов в мессенджерах или в ОС системах на базе `Unix` в командной строке. Поэтому область применения такой структуры данных не
ограничивается только ассоциативными массивами.

## Задания

1. Выберите все верные утверждения, которые относятся к префиксному дереву.

![image](https://user-images.githubusercontent.com/124737857/230773004-3356a0ed-ccc7-4f47-9389-11386511ac7b.png)

![image](https://user-images.githubusercontent.com/124737857/230773022-9750563a-9756-4b40-91ad-a7eb2a1bb180.png)

2. Пусть имеется следующее префиксное дерево:

![image](https://user-images.githubusercontent.com/124737857/230773036-18b08dae-d671-4a97-b7ac-3538984e4e78.png)

Отметьте все пары "ключ-значение", которые оно хранит.

![image](https://user-images.githubusercontent.com/124737857/230773049-8e013da7-e1d2-414d-beda-32cc87d4fb66.png)

![image](https://user-images.githubusercontent.com/124737857/230773087-ffd0a6fd-abbf-4b36-9d0b-0597cb6a7d31.png)

3. Выберите все верные варианты удаления ключа из префиксного дерева.

![image](https://user-images.githubusercontent.com/124737857/230773206-9a5807fd-d285-4f3e-93fa-132eca88ff19.png)

![image](https://user-images.githubusercontent.com/124737857/230773248-fbed6cc2-ebc2-4a61-a165-38c27f039cca.png)


