## Динамические массивы на Python и C++

### Динамический массив в Python

Создать массив можно например, так:

```python
marks = [2, 2, 3, 4]
lst = [True, "Истина", 1, 1.0]
```

Массив - один тип данных, а во втором списке мы видим и булево значение и строку и целое число, то есть, разные типы. Но если мы посмотрим внутрь этой структуры,
то увидим, что на самом деле списки в Python реализованы как динамические массивы ссылок. И эти ссылки могут быть связаны с любым объектом, любого типа.

![image](https://user-images.githubusercontent.com/124737857/227706380-21e8ebc7-4122-4ac1-ab81-47468d56897c.png)

Отсюда и получается эффект, словно список содержит разные типы. На самом деле в нем хранятся только ссылки, ведущие на те или иные объекты и не более того. То есть, сам
динамический массив содержит данные одного типа – ссылки на объекты.

Число хранимых элементов в списке можно определить командой:

```python
n = len(lst)
```

Если требуется добавить новый элемент в этот список, то используется команда:

```python
lst.append(5)
```

В результате в конец списка будет добавлена новая ссылка, связанная с целым значением 5. Скорость этой операции с точки зрения О большого составляет O(1). То есть, 
добавление нового значения в конец списка – это относительно быстрая операция.

Если же мы хотим вставить новое промежуточное значение, например, в середину или начало списка, то это делается с помощью команды:

```python
lst.insert(0, 'First')
```

Здесь первое значение – это индекс вставляемого элемента, а второй аргумент – значение вставляемого элемента. Cкоростью выполнения операции O(n).

Для доступа к отдельным элементам списков используется оператор квадратные скобки:

```python
el_1 = marks[2]     # чтение значения 3-го элемента
marks[1] = 3        # запись значения во 2-й элемент
```

## Объединение списков и срезы

Довольно часто в Python используется операция объединения списков. Например, мы можем соединить два списка в нашем примере следующим образом:

```python
lj = marks + lst
```

Создается новый массив, размером достаточным для хранения всех объединяемых элементов, а затем, в него копируется информация из первого и второго массивов:

![image](https://user-images.githubusercontent.com/124737857/227706558-5ffecd56-9221-4554-a15f-7d5b2300c3e3.png)

Если принять число элементов первого массива за n, а во втором – за m, то вычислительная сложность такой операции с точки зрения О большого составляет: O(n + m)

Другая распространенная операция со списками – это взятие срезов.

```python
lst = [1, 2, 3, 4, 5, 6, 7, 8]
lst2 = lst[1:6]
```

В данном случае список lst2 будет состоять из значений:

```python
lst2 = [2, 3, 4, 5, 6]
```

То есть, при взятии среза создается новый динамический массив и в него копируются данные из первого массива. Сложность этой операции составляет O(n).

### Динамические массивы на С++

Непосредственно в С++ есть только статические массивы. Для динамических, чаще всего, используют класс vector из стандартной библиотеки шаблонов (STL). Поэтому 
вначале нам нужно импортировать модуль vector:

```c++
#include <vector>
```

А, затем, можно объявить динамический массив, например, так:

```c++
vector<float> digits;
```

Здесь в угловых скобках указывается тип элементов динамического массива.

В каждом векторе (динамическом массиве) имеется метод size(), который возвращает число хранимых элементов. Если мы сейчас выведем это значение:

```c++
cout << digits.size();
```

то увидим ноль. Действительно, на данный момент мы не добавили в вектор ни одного значения.

Чтобы добавить новый элемент в конец вектора используется метод:

```c++
digits.push_back(5.0);
digits.push_back(4.0);
digits.push_back(3.0);
digits.push_back(2.0);
```

Соответственно, метод size() возвращает значение 4.

Чтобы получить (прочитать) отдельные значения достаточно записать имя динамического массива и в квадратных скобках указать индекс нужного элемента. Например:

```c++
cout << digits[0] << endl;
```

Если нужно изменить какое-либо значение, то делается все по аналогии следующим образом:

```c++
digits[1] = -5.43f;
```

Вывести все значения вектора в консоль можно следующим образом:

```c++
for (int i = 0; i < digits.size(); i++)
    cout << digits[i] << " ";
```

В ряде случаев бывает полезна операция начальной инициализации вектора определенными значениями. Делается это так:

```c++
vector<float> digits = { 1.0, 2.0, 3.0 };
```

Давайте дополнительно еще выведем значение capacity – физической емкости динамического массива:

```c++
cout << digits.capacity() << endl;
```

Мало того, если нам нужно явно указать размер физического пространства (число элементов), то это можно сделать с помощью метода reserve:

```c++
digits.reserve(20);
```

Теперь, начальный физический размер нашего динамического массива составляет 20 элементов. В ряде случаев это бывает полезно, чтобы подсказать программе, какой 
начальный размер целесообразно выбрать, чтобы лишний раз не формировать новый массив с большим размером.

Еще один распространенный способ инициализации вектора, когда в момент его объявления мы указываем начальный размер следующим образом:

```c++
vector<float> digits(10);
```

В результате получим 10 элементов и все 10 будут заполнены нулями. Если нужно записать другое начальное значение элементов, то оно указывается следующим аргументом:

```c++
vector<float> digits(10, -5.2f);
```

Для удаления последних элементов используется метод pop_back():

```c++
digits.pop_back();
```

В результате логический размер - 9 значений, а capacity при это возвращает прежнее число 10. То есть, при удалении элементов, физический размер массива остается
прежним.

Если нужно удалить все элементы из вектора, это делается методом:

```c++
digits.clear();
```

А метод:

```c++
digits.empty();
```

возвращает булево значение True для пустого массива (когда size() дает 0) и False в противном случае.

Это основные операции с вектором (динамическим массивом) в С++. 

Vожно выполнять вставку новых элементов в произвольную позицию с помощью метода: insert() и удаление промежуточных элементов методом: erase()

Но всегда следует помнить, что вычислительная сложность этих операций составляет O(n), а потому в динамическом массиве их лучше избегать.

### Задания

Для заданий 1 - 3 вывод нужно делать в формате: 1 - для O(1); n - для O(n); log n - для O(log n); n^2 - для O(n^2); n! - для O(n!).

1. Пусть в программе имеется следующий список ваших гостей (в общем случае состоит из n значений):

```python
guests = ["Анна", "Маша", "Федор", "Сергей"]
```

Добавьте в конец этого списка еще одного гостя с именем "Владимир".

Выведите на экран (в консоль) число операций с позиции Big O, необходимых для добавления этого нового значения.

```python
guests = ["Анна", "Маша", "Федор", "Сергей"]

guests.append("Владимир")
print(1)
```

2.  Пусть в программе имеется следующий список значений температуры по дням (в общем случае состоит из n значений):

```python
t = [-27, -23, -20, -12, -8]
```

Необходимо после значения -23 вставить значение -22.

Выведите на экран (в консоль) число операций с позиции Big O, необходимых для вставки этого нового значения.

```python
t = [-27, -23, -20, -12, -8]

insert_ind = t.index(-23)

t.insert(insert_ind + 1, -22)
print("n")
```

3. Пусть в программе имеются два списка котировок доллара по отношению к рублю:

```python
usd_rub1 = [68.5, 69.1, 70.2, 71, 69.54]
usd_rub2 = [60.1, 62.7, 62.5, 65.6]
```

Будем полагать, что первый список usd_rub1, в общем случае, содержит n значений, а второй usd_rub2 - m значений.

Сформируйте список с именем usd_rub, состоящий из объединенных элементов списка usd_rub2 и usd_rub1 (порядок элементов должен быть именно такой: сначала элементы 
списка usd_rub2, а затем - usd_rub1).

Выведите на экран (в консоль) число операций с позиции Big O, необходимых для объединения этих списков в один.

```python
usd_rub1 = [68.5, 69.1, 70.2, 71, 69.54]
usd_rub2 = [60.1, 62.7, 62.5, 65.6]

usd_rub = usd_rub2 + usd_rub1
print("n+m")
```

4. Пусть имеется следующий список и вычисляется его длина:

```python
lst = [1, 2, 3, 4, 5]
sz = len(lst)
```

Какой размер при этом возвращает функция len()?

![image](https://user-images.githubusercontent.com/124737857/227707167-318e6508-79bb-4288-8165-b3bfabece965.png)

5. Пусть в программе имеется некоторый список, в общем случае длиной n элементов к нему применяется следующая операция среза:

```python
lst = [5, 4, 3, 78, -1, 100]
lst_2 = lst[1::2]
```

Каков объем вычислений при операции среза с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227707211-1ea504e5-99bd-4c02-ae47-9522496d17a6.png)

6. В программе формируется список (в общем случае из n элементов) следующим образом:

```python
lst = ["noname"] * n
```

где n - некоторое целое положительное число. Какова вычислительная сложность этой операции (формирования списка) с позиции О большого?

![image](https://user-images.githubusercontent.com/124737857/227707274-d9b13011-b996-4b0d-8338-ef3989be5e88.png)

7. В программе формируется квадратная единичная матрица размером n x n элементов следующим образом:

```python
I = [[1 if i == j else 0 for i in range(n)] for j in range(n)]
```

Какова вычислительная сложность этой операции (формирования списка) с позиции О большого?

![image](https://user-images.githubusercontent.com/124737857/227707309-27401c9d-70eb-4422-9956-d37cc3db55f1.png)


8. Выберите верные варианты создания объекта динамического массива (класса vector) на С++.

![image](https://user-images.githubusercontent.com/124737857/227708593-42e79523-7515-40ec-9f2e-3d97a302e510.png)

![image](https://user-images.githubusercontent.com/124737857/227708863-023b1431-48b9-4043-bbc3-4e2c44d47b14.png)

9. В программе объявлен динамический массив, в который заносятся данные из входного потока:

```c++
vector<short> ar_sh;

short x;
while (!feof(stdin)) {
	cin >> x;
	ar_sh.push_back(x);
}
```

Вставьте в этот массив третий по счету элемент со значением 5 (счет начинается с единицы) и удалите два последних элемента. Выведите на экран полученные значения 
массива ar_sh в одну строчку через пробел.

```c++
#include <iostream>
#include <vector>

int main(void)
{
    using namespace std;

    vector<short> ar_sh;

    short x;
    while (!feof(stdin)) {
        cin >> x;
        ar_sh.push_back(x);
    }

    auto it = ar_sh.begin();

    ar_sh.insert(it + 2, 5);
    ar_sh.pop_back();
    ar_sh.pop_back();

    for (int i = 0; i < ar_sh.size(); i++) cout << ar_sh[i] << " ";

    return 0;
}
```

10. Пользователь вводит с клавиатуры натуральное число (тип int), используя следующие команды:

```c++
int digit;
cin >> digit;
```

Необходимо найти все делители введенного числа digit и сохранить их в динамическом массиве с именем divs (элементы массива должны иметь тип int, а делители 
добавлять в конец массива в порядке возрастания значений).

Выведите на экран в одну строчку через пробел все найденные делители, начиная с числа 1 и заканчивая самим числом.

```c++
#include <iostream>
#include <vector>

int main(void)
{
    using namespace std;

    vector<int> divs;
    int digit;
    cin >> digit;
    
    for (int i = 1; i <= digit; i++){
        if (digit % i == 0) divs.push_back(i);
    }
    
    for (int i = 0; i < divs.size(); i++) cout << divs[i] << " ";
    return 0;
}
```

11. Необходимо объявить динамический массив с именем path, который бы хранил координаты маршрута в виде целочисленных переменных x, y. Для описания точки маршрута
в программе перед функцией main() должна быть объявлена следующая структура:

```c++
typedef struct {
	int x, y;
} POINT;
```

То есть, элементы динамического массива path должны иметь тип POINT.

Добавьте в массив path следующие координаты:

(0, 0); (20, -5); (30, 10); (100, 0); (175, 80)

Выведите на экран в первой строчке через пробел все координаты x (первую координату), а во второй - все координаты y (вторую координату) также через пробел. 

После второй строчки сделайте перевод на новую строку (например, командой cout << endl;)

```c++
#include <iostream>
#include <vector>

typedef struct {
    int x, y;
} POINT;

int main(void)
{
    using namespace std;
    vector<POINT> path = { {0, 0}, {20, -5}, {30, 10}, {100, 0}, {175, 80} };

    for (int i = 0; i < path.size(); i++)
        cout << path[i].x << " ";

    cout << endl;

    for (int i = 0; i < path.size(); i++)
        cout << path[i].y << " ";

    cout << endl;
    return 0;
}
```

12. Вам необходимо реализовать неравномерную таблицу из оценок студентов, как показано на рисунке ниже:

![image](https://user-images.githubusercontent.com/124737857/227722473-6847c372-4629-4e1b-b2aa-b50a5ec69678.png)


Здесь каждая строчка таблицы является динамическим массивом: marks[0], marks[1], ... marks[9]. Всего в таблице 10 строчек. Следовательно, в программе нужно объявить
массив размером в 10 элементов, состоящий из динамических массивов:

```c++
vector<char> marks[10];
```

Занесите в первые 6 строчек таблицы оценки, показанные на рисунке, в виде целых чисел (а не символов).

```c++
#include <iostream>
#include <vector>

int main(void)
{
    using namespace std;
    vector<char> marks[10];

    marks[0].push_back(3);
    marks[0].push_back(4);
    marks[1].push_back(2);
    marks[2].push_back(5);
    marks[2].push_back(5);
    marks[2].push_back(5);
    marks[3].push_back(2);
    marks[3].push_back(2);
    marks[3].push_back(2);
    marks[3].push_back(2);
    marks[3].push_back(2);
    marks[4].push_back(1);
    marks[4].push_back(3);
    marks[5].push_back(3);
    return 0;
}
```
