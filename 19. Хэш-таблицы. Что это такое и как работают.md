## Хэш-таблицы. Что это такое и как работают

Хэш-таблица для стандартных операций вставки, чтения и удаления данных, в среднем, выполняется за константное время `O(1)`.

![image](https://user-images.githubusercontent.com/124737857/230776324-2e90cf79-98d5-4d86-ab1d-e251b8ea5772.png)

Рассмотрим принцип работы хэш-таблиц.

Предположим, в продуктовом магазине необходимо хранить товары и выдавать цену по их названиям.

|Товар| Цена |
|-----|------|
|Бананы| 100|
|Брокколи| 200|
|Сыр «Папандос»| 150|
|… |            |

В связный список можно достаточно быстро можно добавлять новые товары и удалять ненужные. Правда, поиск будет выполняться линейное время `O(n)`.
И это нас не очень устраивает, т.к. товаров в магазине может быть очень много и нам бы хотелось иметь быстрый доступ к цене товара по его названию. Поэтому
будем использовать динамические массивы.

![image](https://user-images.githubusercontent.com/124737857/230776395-2867d76a-c6b0-4558-8e28-282e351891e9.png)

Но здесь сразу две проблемы: во-первых, мы знаем названия, но не индексы элементов, а значит, поиск нужного товара займет `O(n)` времени, и, во-вторых,
операции добавления и удаления товара также потребуют `O(n)` времени. Однако, придумаем алгоритм, который бы переводил названия товаров в индексы, и тогда, мы получим
возможность сразу обращаться к нужной ячейке таблицы(массива), чтобы записать его туда, прочитать оттуда, или удалить, когда это потребуется:

![image](https://user-images.githubusercontent.com/124737857/230776413-fbea3e92-91e2-424a-9dcd-79e958911525.png)

Так вот, алгоритм преобразования некоторой строки в индекс массива получил название хэш-функция, а процесс его работы – хэширование. Отсюда пошло название хэш-таблица.

Хэш-функция должна обладать следующими свойствами:

 - для одного и того же ключа (названия товара) должна выдавать одно и то же значение (свойство последовательности);
 - для разных ключей (названий товаров) выдавать разные значения (индексы);
 - формируемые значения должны находиться в диапазоне от 0 до `N-1`, где `N` – размер массива;
 - возможные ключи (названия) должны равномерно записываться в ячейки таблицы.

Возникает вопрос, можно ли вообще построить такую функцию? В общем случае нет. Хотя бы исходя из того, что количество ключей может быть огромное количество `K`. И оно
явно больше числа ячеек таблицы (размера массива) `M`. Поэтому мы просто не сможем всем ключам выдать уникальные индексы. Вторая проблема – это равномерность
заполнения таблицы. Хорошая хэш-функция должна разные ключи как можно равномернее распределять по массиву, минимизируя, тем самым, дублирование индексов.

Будем полагать, что у нас уже есть алгоритм хэширования, и посмотрим на работу хэш-таблиц в целом.

## Добавление элементов в хэш-таблицу

Давайте предположим, что мы бы хотели по английским буквам получать соответствующие аналоги русских букв. Например:

| Ключ | Значение
| -----| -------|
|a | а|
|b | б|
|c | с|
|d | д|
|f | ф|
|… | …|

Причем нам наперед неизвестно, сколько именно букв  будет храниться в хэш-таблице. Поэтому, чтобы зря не расходовать память, начальный размер таблицы будет иметь `m=5`
элементов. Сами ячейки таблицы будут хранить адреса на объекты с данными. Если данных нет, то указатели принимают значение `NULL`. Далее, у нас имеется хэш-функция,
которая для каждой буквы латинского алфавита вычисляет индекс в массиве `T`. Предположим, мы хотим по ключу `b` записать значение `б`. На вход хэш-функции подается
символ `b`. На выходе получаем индекс массива, по которому этот ключ должен располагаться в таблице. Пусть это будет индекс 1:

![image](https://user-images.githubusercontent.com/124737857/230776544-1604ed7c-0832-41b9-8cb5-58a25994f9fb.png)

Затем, в памяти создается новый объект с ключом `b` и значенем `б`, и адрес этого объекта сохраняется во втором элементе таблицы. То есть, массив хранит не сами данные,
а ссылки на объекты с данными. Это наиболее частая реализация хэш-таблиц. В результате мы добавили новый ключ `b` и его значение `б` в хэш-таблицу. На уровне языков
программирования эта операция часто записывается в виде:

```python
T["b"] = "б"
```

По аналогии можно добавить еще несколько ключей и значений. Например, ключи `f`, `d`, `u`:

![image](https://user-images.githubusercontent.com/124737857/230776571-c30214c5-f427-4d66-9906-0dee8bcefd1a.png)

В теории хэш-таблиц степень их заполненности определяется коэффициентом:

```
α = n / m
```

где `n` – количество хранимых ключей (в нашем примере 4); `m` – размер массива (в нашем примере 5). Получаем, значение степени заполнения таблицы:

```
α = 4 / 5 = 0,8
```

То есть, пока этот коэффициент меньше единицы, в массиве есть свободные элементы, куда теоретически еще можно добавить новые ключи. Если `α = 1`, то массив заполнен
полностью. Если же `α > 1`, то число ключей превышает размер хэш-таблицы.

На данный момент коэффициент `α = 0.8`, значит, массив почти заполнен. Выход только один: увеличить размер таблицы, то есть, рассматривать массив как динамический и,
например, при `α` близкой к 1 увеличивать его размер в 2 раза.

Сначала мы должны в памяти создать новый массив длиной в 2 раза больше предыдущего. После этого хэш-функция будет уже выдавать новый диапазон индексов `[0; 9]`.
Поэтому элементы должны не просто копироваться в новый массив, а заново прогоняться через новую хэш-функцию.

Получим (как пример):

![image](https://user-images.githubusercontent.com/124737857/230776598-4b24356b-eaf8-4956-9808-11cbdfcfb1ef.png)

Только после этого мы сюда можем добавлять новые ключи. Вот общий принцип работы алгоритма добавления ключей и значений в хэш-таблицы. В среднем, эта операция
выполняется за фиксированное время `O(1)`.

## Разрешение коллизий в хэш-таблицах

Однако, такая идеализированная картина, когда в одной ячейке хранится одно значение, бывает только в простых случаях, когда число ключей невелико и все их можно
разнести по разным индексам. На практике же общее возможное число ключей `K` стремится к бесконечности, их вариации могут быть самыми разными и рано или поздно
возникает ситуация, когда разным ключам хэш-функция назначает один и тот же индекс:

![image](https://user-images.githubusercontent.com/124737857/230776626-ab3766da-756c-42de-9dec-e4389c4c0813.png)

И избежать этого невозможно, так как алгоритмически мы должны обеспечивать не только различие в индексах, но и равномерность заполнения таблицы. Кроме того, число
ячеек `M` в таблице много меньше возможного числа ключей. Поэтому вполне вероятны ситуации, когда разным ключам назначается один и тот же индекс. Такая ситуация
называется коллизией. 

Существует два основных метода разрешения коллизий:

 - метод цепочек;
 - метод открытой адресации.

Самый простой и очевидный способ обработки коллизий – это метод цепочек. Давайте предположим, что в хэш-таблицу T осуществляется добавление следующих пар
ключ-значение:

```python
T["b"] = б
T["ba"] = ба
T["d"] = д
T["f"] = ф
T["bb"] = бб
T["fa"] = фа
```

![image](https://user-images.githubusercontent.com/124737857/230777521-e0973c22-46d7-43ac-9448-67fc7e8e5f35.png)

И хэш-функция для ключей с одинаковыми первыми буквами выдает одни и те же индексы таблицы. Тогда, чтобы сохранить несколько разных ключей по одному и тому же
индексу, формируется двусвязный список, на начало которого ведет указатель `ptr`. В элементах этого двусвязного списка сохраняются пары ключ-значение. Это и есть
принцип разрешения коллизий по методу цепочек.

У такого решения есть положительные и отрицательные стороны. К положительным можно отнести простоту реализации. Также относительно быстро происходит вставка новых
ключей и удаление существующих в таких списках (цепочках). А основным недостатком является возможность появления длинных цепочек в хэш-таблицах. Тогда преимущества
хэш-таблиц будут сведены к нулю. Чтобы избежать образования длинных цепочек, нужно правильно выбирать хэш-функцию, которая бы равномерно распределяла возможные ключ
и по индексам таблицы. Существуют подходы, позволяющие создавать такие функции.

Посмотрим, как в хэш-таблицах со списками выполняется поиск и удаление ключей.

## Алгоритм поиска ключей

Имеется ранее сформированная хэш-таблица с цепочками и в ней требуется взять значение по определенному ключу. Пусть это будет ключ `«ba»`, то есть, нужно выполнить
операцию:

```python
val = T["ba"]
```

Для этого мы подаем ключ `«ba»` на вход хэш-функции, получаем значение индекса 1 в таблице и видим здесь двусвязный список. На начало этого списка ведет указатель
`ptr`.

Сформируем временный указатель:

```python
p = ptr
```

который также будет ссылаться на начало этого списка. Далее, мы последовательно проходим по элементам этого списка и сравниваем в них ключи на равенство заданного
ключа `«ba»`. Этот ключ мы находим во втором элементе списка. На этом поиск останавливается и возвращается значение `"ба"` этого ключа.

Если мы указываем не существующий ключ, например, `«t»`, то либо попадем в пустую ячейку таблицы, либо не найдем этот ключ в списке.

## Алгоритм удаления ключей

Посмотрим, как можно выполнять удаление существующих ключей из хэш-таблицы с цепочками. У нас по-прежнему будет та же самая таблица и мы хотим удалить из нее ключ `«ba»`:

```python
del T["ba"]
```

Подаем этот ключ на вход хэш-функции и получаем индекс 1 в таблице. По этому индексу хранится несколько ключей в двусвязном списке. С помощью
временного указателя `p` находим элемент с ключом `«ba»`. Это второй элемент. И удаляем его.

Если происходит удаление единственного ключа в ячейке, например, ключа `«d»`, то проверяется, что в единственном элементе действительно хранится ключ `«d»`, если так,
то объект удаляется и ячейка принимает значение `NULL`.

Наконец, если пытаемся удалить не существующий в таблице ключ, например, `«s»`, то либо сразу попадаем в ячейку со значением `NULL`, либо на цепочку из ключей, в которой
ключ `«s»` будет отсутствовать.

## Задания

1. Выберите все верные утверждения для хэш-таблиц.

![image](https://user-images.githubusercontent.com/124737857/230779811-6f874223-9c4d-41bf-846d-9feb96d1b4ec.png)

![image](https://user-images.githubusercontent.com/124737857/230779858-62bfa1ec-2f49-46ee-8dc2-a62abf2e94ab.png)

2. Выберите все верные утверждения для хэш-функции.

![image](https://user-images.githubusercontent.com/124737857/230779875-6d6abc77-89e3-42c3-85d7-6fe6c08159f8.png)

![image](https://user-images.githubusercontent.com/124737857/230779915-f4e81acf-529f-4068-bebe-52d4172555de.png)

3. Пусть хэш-таблица представляется объектом `T`. И с ней выполняется следующая команда:

```python
T["python"] = 1
```

Выберите все верные утверждения, связанные с этой командой.

![image](https://user-images.githubusercontent.com/124737857/230779991-c62c5d89-f102-4997-af37-11f9633689f1.png)

![image](https://user-images.githubusercontent.com/124737857/230780048-5d629606-5282-4b4f-82c1-5cd2862c3fb9.png)

4. Пусть имеется хэш-таблица размером в 10 элементов, представленная объектом `T`. В эту хэш-таблицу было записано 4 элемента. Чему равен коэффициент заполнения этой
хэш-таблицы?

![image](https://user-images.githubusercontent.com/124737857/230780093-ac33a254-c1ce-4212-90c5-4d79a96a86fc.png)

5. Какие действия выполняются с хэш-таблицей, когда ее коэффициент заполнения приближается к единице?

![image](https://user-images.githubusercontent.com/124737857/230780111-5bbc8a87-d9ba-4cfd-9f49-8d7af31fa343.png)

![image](https://user-images.githubusercontent.com/124737857/230780145-97ff7484-d55d-4124-b6fc-f51415b76128.png)

6. Что понимают под термином "коллизии" в хэш-таблицах?

![image](https://user-images.githubusercontent.com/124737857/230780174-f5dd11e6-4995-40cc-98d7-005fd9bb9c19.png)

7. Выберите все верные утверждения для алгоритма поиска ключей в хэш-таблице, реализующей метод цепочек при разрешении коллизий.

![image](https://user-images.githubusercontent.com/124737857/230780214-acfbaa6f-cb2a-459a-8700-17b36cc4145c.png)

![image](https://user-images.githubusercontent.com/124737857/230780320-db84e260-faaf-49c5-a9b0-0cf3dc498c11.png)

8. Отметьте объем вычислений для типовых операций с хэш-таблицей, реализующей метод цепочек при разрешении коллизий, при наихудшем случае ее работы. Полагается, что
хэш-таблица хранит `n` элементов.

![image](https://user-images.githubusercontent.com/124737857/230780447-c587630f-5ca5-46ab-b1d8-7b23e2611dd8.png)

![image](https://user-images.githubusercontent.com/124737857/230780463-d3d45fd6-ee10-404e-9dc3-5f416da14a03.png)

9. Выберите все верные утверждения для алгоритма удаления ключей из хэш-таблицы, реализующей метод цепочек при разрешении коллизий.

![image](https://user-images.githubusercontent.com/124737857/230780504-f176ffe1-71d9-47d4-bde1-65a3e192ae4d.png)

![image](https://user-images.githubusercontent.com/124737857/230780694-25b7981b-de09-4527-8563-c46c0e4a2663.png)



