## Двусвязный список. Структура и основные операции

**Двусвязный список** – аналогичен односвязному, только каждый элемент имеет ссылки next и prev на следующий и предыдущий элементы.

![image](https://user-images.githubusercontent.com/124737857/227805184-a480cc78-9ea7-43f7-80b1-1751527980a7.png)

Также мы имеем здесь два указателя: head – на первый элемент списка; tail – на последний. В результате, можно очень быстро обрабатывать первые и последние элементы, например, делать добавление элементов в начало списка или в конец, а также удалять их. У граничных объектов указатель prev и next принимают значения NULL.

### Добавление элементов в начало и конец двусвязного списка

Предположим, что в списке два объекта и мы хотим добавить новый в его конец:

![image](https://user-images.githubusercontent.com/124737857/227805259-4655c5b0-2bd9-44b1-ade2-45ba9ab22040.png)

Вначале создается новый элемент в памяти компьютера, на который ведет временная ссылка ptr. Затем, ссылка next последнего объекта списка должна вести на этот новый объект. Для этого достаточно присвоить ссылке адрес нового элемента:

```python
tail.next = ptr
```

Далее необходимо ссылке prev нового элемента присвоить адрес последнего элемента списка:

```python
ptr.prev = tail
```

И последнее, указатель tail переместить на новый последний элемент списка:

```python
tail = ptr
```

Скорость работы этой операции составляет O(1) и часто реализуется командой push_back().

По аналогии выполняется добавление нового элемента в начало двусвязного списка. Создается новый объект, на который ссылается указатель ptr. Затем, ссылка prev первого объекта должна вести на добавляемый элемент:

```python
head.prev = ptr
```

Ссылка next добавляемого элемента должна вести на объект head:

```python
ptr.next = head
```

И указатель head перемещаем на объект ptr:

```python
head = ptr
```

Скорость выполнения этой операции с точки зрения О большого составляет O(1) и часто реализуется командой push_front().

### Доступ к произвольному элементу двусвязного списка

Предположим, имеется список из нескольких элементов и указатели head и tail, которые ссылаются на первый и последний элементы этого списка. Затем, создадим еще один временный указатель ptr, который пусть изначально ссылается на первый элемент:

![image](https://user-images.githubusercontent.com/124737857/227805591-34f4e1f7-cec3-4f47-8a7b-4b2d7d44afa7.png)

Через указатель ptr обращаемся к первому элементу и можем, например, прочитать его данные командой:

```python
value = ptr.data
```

Чтобы перейти к следующему второму элементу необходимо переместить указатель ptr на него. Сделать это можно очень просто с помощью указателя next первого объекта:

```python
ptr = ptr.next
```

Получаем доступ ко второму элементу списка. Можем записывать и считывать из него данные:

```python
ptr.data = new_value
```
И так можно проходить по всем элементам списка до последнего.

С точки зрения О большого объем вычислений для перехода к произвольному k-му элементу списка составляет O(n), где n – общее число элементов в списке.

Но у двусвязных списков есть важное преимущество по сравнению с односвязными списками: мы можем перемещаться по элементам в обе стороны (и вправо и влево). В частности, это несколько упрощает некоторые операции, например, удаление промежуточных элементов.

### Вставка элемента в двусвязный список

Предположим, в списке имеется три элемента и мы хотим вставить новый элемент после второго, на который ссылается указатель left:

![image](https://user-images.githubusercontent.com/124737857/227805739-21bc0dc4-3fa8-4851-b355-cdcc8525805c.png)

Затем, создается новый объект в памяти устройства, на который ссылается временный указатель ptr. Все что осталось – это настроить связи между соседними элементами относительно вставляемого. Для этого создадим еще один временный указатель right, который будет ссылаться на следующий элемент после left:

```python
right = left.next
```

В результате мы имеем ссылки left и right на соседние объекты относительно вставляемого.

Сформируем новые связи между элементами. Первые две связи между объектом left и ptr, очевидно, создаются командами:

```python
left.next = ptr
ptr.prev = left
```

А следующие две (между right и ptr) командами:

```python
right.prev = ptr
ptr.next = right
```

Вычислительная сложность непосредственно вставки нового элемента, составляет O(1). Но здесь нужно учитывать, что прежде необходимо получить ссылку на объект left, после которого вставляется новый элемент. А эта операция выполняется за O(n). Поэтому, в общем случае, вставка нового элемента в двусвязный список имеет сложность O(n).

### Удаление промежуточных элементов

Предположим, имеется список из четырех элементов и мы хотим удалить третий. На него ведет указатель node:

![image](https://user-images.githubusercontent.com/124737857/227805916-5b84ef3c-bf9d-455c-bfc7-575d1cb82e6c.png)

Первым шагом нам нужно получить ссылки на соседние объекты относительно удаляемого. Это можно сделать командами:

```python
left = node.prev
right = node.next
```

Затем, освободить память, занимаемую объектом node.

```c++
delete node
```

Осталось только изменить связи у объектов left и right (связать их между собой):

```python
left.next = right
right.prev = left
```

Все, связи настроены и удаление промежуточного элемента выполнено. Вычислительная сложность самой операции удаления составляет O(1). С учетом поиска удаляемого элемента – O(n).

### Удаление первого и последнего элементов

Предположим, в списке имеется четыре элемента и мы собираемся удалить первый.

![image](https://user-images.githubusercontent.com/124737857/227806037-ea58e371-fc3f-42f4-a181-daab84fda410.png)

Тогда создадим временный указатель ptr, который будет ссылаться на следующий (второй) элемент:

```python
ptr = head.next
```

И у этого второго элемента указатель prev приравняем значению NULL:

```python
ptr.prev = NULL
```

Затем, освободим память, занимаемую первым элементом head:

```c++
delete head
```

И переместим указатель head на второй элемент, который теперь стал первым:

```python
head = ptr
```

Вычислительная сложность этого алгоритма составляет O(1) и часто реализуется командой pop_front().

По аналогии выполняется удаление последнего элемента. Вначале формируем временный указатель ptr на предыдущий объект списка:

```python
ptr = tail.prev
```

Затем, указатель next объекта ptr приравниваем значению NULL:

```python
ptr.next = NULL
```

Освобождаем память из под последнего элемента:

```c++
delete tail
```

И устанавливаем указатель tail на новый последний элемент:

```python
tail = ptr
```

Вычислительная сложность этого алгоритма составляет O(1) и часто реализуется командой pop_back().

|               | Команда | Big O |
| ------------- | ------------- | ------------ |
| Добавление в начало  | push_front() | O(1) |
| Добавление в конец  | push_back() | O(1) |
| Удаление с конца  | pop_back() | O(1) |
| Удаление с начала  | pop_front() | O(1) |
| Вставка элемента  | insert() | O(n) |
| Удаление промежуточных элементов  | erase() | O(n) |
| Доступ к элементу  | iterator | O(n) |

### Задания

1. Отметьте все преимущества двусвязного списка перед односвязным.

![image](https://user-images.githubusercontent.com/124737857/228050733-3ac7746d-5441-462e-853b-a2a819ebb34e.png)

![image](https://user-images.githubusercontent.com/124737857/228050911-19be6c6b-3f92-4d37-a68b-7f5d60da3025.png)

2. Пусть на первый объект двусвязного списка ссылается указатель head, а на последний tail. Каждый объект списка имеет указатель next на следующий элемент и prev на предыдущий. Предположим, что в списке 7 элементов. Выберите наборы команд (написаны на языке Python), которые позволяют перейти к 3-му элементу этого списка.

![image](https://user-images.githubusercontent.com/124737857/228053563-3cb7ab88-616c-4936-a6da-f8bff0619555.png)

![image](https://user-images.githubusercontent.com/124737857/228057109-8ac5f23a-805c-4ffc-b883-dfbae4960876.png)

3. Какой из набора команд (на языке Python) выполняет добавление нового элемента: 

```python
ptr = Node()
ptr.next = ptr.prev = None
```

в начало двусвязного списка, на который имеются ссылки head (на первый элемент) и tail (на последний элемент). Каждый объект списка имеет ссылку next на следующий элемент и prev на предыдущий.

Здесь полагается, что в двусвязном списке имеется хотя бы один элемент.

![image](https://user-images.githubusercontent.com/124737857/228057272-d3f3f5d3-0126-44e1-8661-bc14492e7051.png)

![image](https://user-images.githubusercontent.com/124737857/228057606-0b4a99f9-13b0-409f-8ffc-db11e383d68a.png)

4. Какой из набора команд (на языке Python) выполняет добавление нового элемента: 

```python
ptr = Node()
ptr.next = ptr.prev = None
```

в конец двусвязного списка, на который имеются ссылки head (на первый элемент) и tail (на последний элемент). Каждый объект списка имеет ссылку next на следующий элемент и prev на предыдущий.

Здесь полагается, что в двусвязном списке имеется хотя бы один элемент.

![image](https://user-images.githubusercontent.com/124737857/228057709-00a4a6c6-c818-4ff5-89b7-a71d830efadc.png)

![image](https://user-images.githubusercontent.com/124737857/228057822-0eac21a3-ffbd-431d-8767-f9c6a181fdf6.png)

5. Какой из набора команд (на языке Python) выполняет удаление элемента с конца двусвязного списка, на который имеются ссылки:

 - head - на первый элемент;
 - tail - на последний элемент.

Каждый объект списка имеет ссылку next на следующий элемент и prev на предыдущий.
Полагается, что в двусвязном списке имеются хотя бы два элемента.

![image](https://user-images.githubusercontent.com/124737857/228057939-fffca3e8-97e4-4ac4-a654-854203f20c57.png)

![image](https://user-images.githubusercontent.com/124737857/228058537-46d58a7b-e10c-4af1-b855-3bd13e2d0fff.png)

6. Какой из набора команд (на языке Python) выполняет удаление элемента с начала двусвязного списка, на который имеются ссылки:

 - head - на первый элемент;
 - tail - на последний элемент. 

Каждый объект списка имеет ссылку next на следующий элемент и prev на предыдущий.
Полагается, что в двусвязном списке имеются хотя бы два элемента.

![image](https://user-images.githubusercontent.com/124737857/228058709-4b48af78-7b93-42c3-9489-1c14715b1d16.png)

![image](https://user-images.githubusercontent.com/124737857/228058859-e04e5e1c-f849-44ac-b102-859397f022fc.png)

7. Какой из набора команд (на языке Python) выполняет удаление промежуточного элемента из двусвязного списка, на который ведет указатель ptr? При этом полагается, что в двусвязном списке имеются элементы до и после объекта, на который ведет указатель ptr:

```python
left = ptr.prev
right = ptr.next
```

![image](https://user-images.githubusercontent.com/124737857/228058970-3fa9abc9-f82a-4d48-b98e-3c1a5e2f2737.png)

![image](https://user-images.githubusercontent.com/124737857/228059149-4cb19073-c19f-4a22-a7c9-e5cc5d865f24.png)

8. Какой из набора команд (на языке Python) выполняет вставку в двусвязный список нового элемента:

```python
ptr = Node()
```

после объекта, на который ведет указатель left?

![image](https://user-images.githubusercontent.com/124737857/228059254-7299eddd-64ac-42b3-a622-112164aa1654.png)

![image](https://user-images.githubusercontent.com/124737857/228059525-ba119640-e2a7-4aa1-af5b-2e4b93beb936.png)
