## Хэш-функции. Универсальное хэширование

На вход алгоритма хэширования подается некий ключ, например, `«d»`. На выходе получаем индекс ячейки массива, куда записывается значение
этого ключа:

![image](https://user-images.githubusercontent.com/124737857/230781824-a42716ec-49ad-49e5-80f9-f0e912745486.png)

В качестве ключей хэш-таблиц можно использовать любую байтовую последовательность. На уровне компьютера – это она воспринимается, как конечная
последовательность из целых чисел в диапазоне от `0` до `255` включительно, например (в соответствии с кодовой таблицей `ASCII`):

```python
"for" – "102, 111, 114"
"53$%!" – "53, 51, 36, 37, 33"
```

И так для любой байтовой последовательности. Затем, над этими числами выполняются какие-либо алгоритмические и математические операции так, чтобы свести все к
одному числу `k`, как правило, целому и неотрицательному. После этого полученное число передается в качестве аргумента непосредственно в функцию хэширования, которая
возвращает индекс массива:

```
i = h(k)
```

Вот основные этапы преобразования начального ключа в индекс таблицы при хэшировании.

## Способы построения хэш-функций

В общем случае, мы наперед не знаем, какие ключи `k` будут подаваться на вход хэш-функции. Очевидно, что возможное количество этих ключей `K` много больше
текущего числа ячеек `M` в хэш-таблице. Значит, хэш-функция `h(k)` отображает большее множество `K` в меньшее `M`. И как бы мы ни выбирали функцию `h(k)`, обязательно
будет существовать пара ключей `k1`, `k2`, которым функция `h(k)` назначит один и тот же индекс. Лучшее, что мы здесь можем сделать – это минимизировать вероятность
такого события. А это, в свою очередь, приводит к равномерности распределения хэш-функцией возможных ключей `{k}` по ячейкам таблицы. 

В этом случае можно доказать, что средняя длина цепочек в хэш-таблице будет равна коэффициенту заполнения:

```
α = n / m,
```

где `n` – число хранимых ключей; `m` – общее число ячеек в таблице. И алгоритмы поиска/удаления ключей, в среднем, будут выполняться за:

```
1 + α
```
операций. Это среднее минимальное число, которое может быть достигнуто.

## Построение хэш-функции методом деления

Наверное, самое простое, что мы можем сделать, чтобы преобразовать множество целых неотрицательных чисел `{k}` (ключи) в диапазон значений `[0; m-1]` (индексы таблицы)
– это взять и вычислить остаток от деления операцией:

```
h(k) = kmodm
```

На выходе имеем множество целых значений в нужном нам диапазоне `[0; m-1]`.

Число `m` не должно быть степенью 2, поскольку если m = $2^p$, то `h(k)` представляет собой просто `р` младших битов числа `k`.

Чтобы этого избежать, число `m` следует выбирать, во-первых, простым, а, во-вторых, как можно более далеким от степени двойки, то есть, от чисел $2^p$. Но это, в
свою очередь, накладывает определенные ограничения на размер `m` таблицы, что не очень удобно, так как размер хэш-таблицы может меняться по мере ее заполнения.

## Построение хэш-функции методом умножения

Другой метод умножения для построения хэш-функций:

```
h(k) = ⌊m * ((k * A) mod 1)⌋
```

Здесь `A` – некоторая константа, выбранная из диапазона `0 < A < 1` так, чтобы при умножении `k` на `A` формировалось дробное число, а затем, с помощью операции `mod 1`
выделяется эта дробная часть числа. Благодаря этому, мы как бы перемешиваем возможные значения ключей `{k}`, формируем случайные числа, зависящие от `k`, причем, эти
числа находятся в диапазоне `[0; 1)`. Все что нам остается – это расширить диапазон до `[0; m-1]` в целых числах. Для этого вещественное число умножается на `m` с
округлением до наименьшего целого.

Константу `A` берется равной: ($sqrt(5) - 1$)/2 $\approx$ 0.618

## Другие алгоритмы хэширования

В практике построения хэш-таблиц также строят хэш-функции на базе известных алгоритмов из криптографии:

 - CRC – циклический избыточный код;
 - MD5 – 128-битный алгоритм хэширования;
 - SHA – семейство алгоритмов хэширования.

## Универсальное хэширование

Как бы хорошо не работал алгоритм хэширования остается одна важная проблема: для каждой конкретной функции `h(k)` всегда можно подобрать такой набор ключей `{k}`,
что все они будут располагаться в одной ячейке хэш-таблицы, то есть, для всех них функция выдаст одно и то же значение. Этим обстоятельством, например, может
воспользоваться злоумышленник, чтобы специально замедлить работу программы.

**Универсальный** набор хеш-функций - множество разных хэш-функций, которые выдают независимый набор индексов для одного и того же набора входных значений `{k}`. 
Можно построить по правилу: $h(k) = ((ak + b) mod p) mod m $

где `p` – некоторое простое число, которое больше размера таблицы `m`; a $\in$ {1, 2, ... p - 1}, b $\in$ {0, 1, ..., p - 1} - целые числа, взятые из указанного
диапазона. 

В результате, всего мы имеем:  `N = p * (p - 1)` различных хэш-функций. Причем значение `m` выбирается произвольным образом. Любая выбранная хэш-функция выдаст одно и
то же значение (индекс) с вероятностью `1/m`, где `m` – размер хэш-таблицы. То есть, ключи распределяются равномерно.

В результате, злоумышленник не сможет наперед знать, какая именно будет использована хэш-функция, а значит, не сможет подготовить проблемный набор ключей `{k}` для
образования длинных цепочек в хэш-таблице.


## Задания

1. Отметьте свойства, присущие "хорошей" хэш-функции.

![image](https://user-images.githubusercontent.com/124737857/230785743-6e6d3ba6-3b71-4b4f-b93f-ec20ecc5c374.png)

![image](https://user-images.githubusercontent.com/124737857/230785767-912eb106-9a48-432d-908a-477b1263933f.png)

2. Пусть имеется хэш-функция `h(k)`, которая ключи `k` (в виде положительных целых чисел) переводит в индексы ячеек хэш-таблицы по следующей формуле:

```python
h(k) = k % 32
```

Что можно сказать о свойствах этой хэш-функции и хэш-таблицы, для которой она применяется?

![image](https://user-images.githubusercontent.com/124737857/230785860-1eb3ff5e-ce0e-4ce3-a9e1-fd9a2043f379.png)

![image](https://user-images.githubusercontent.com/124737857/230785938-a39bb591-0efe-45e6-8ae1-e6012e220498.png)

3. Отметьте недостатки, присущие хэш-функциям вида:

```python
h(k) = k % p
```

где `p` - некоторое натуральное число; `k` - значение ключа (целые положительные числа).

![image](https://user-images.githubusercontent.com/124737857/230785988-8ad961c9-e6d6-47fe-9f6f-e921f5709d9e.png)

![image](https://user-images.githubusercontent.com/124737857/230786036-572d68ca-45f6-4277-88df-f402ee83429d.png)

4. Предположим, что мы собираемся построить хэш-функцию `h(k)` по методу умножения в соответствии со следующим математическим выражением:

```python
h(k) = ceil(m * ((k * A) mod 1))
```

где `ceil(x)` - функция округления до наименьшего целого; `m` - число ячеек хэш-таблицы; `k` - значение ключа (целые положительные числа); `A` - некоторая вещественная
константа в диапазоне (0; 1).

Выберите все верные утверждения, связанные с этим выражением.

![image](https://user-images.githubusercontent.com/124737857/230786093-aaf5f654-1fc4-4407-9196-51c930e6a733.png)

![image](https://user-images.githubusercontent.com/124737857/230786161-cf5705d6-da9c-48b2-be20-e55feecf1e58.png)

5. Отметьте все верные утверждения, связанные с термином "универсальное хэширование".

![image](https://user-images.githubusercontent.com/124737857/230786191-1bd98b0e-037d-4ee8-93de-6395290d6369.png)

![image](https://user-images.githubusercontent.com/124737857/230786229-202a6f92-c1a3-440b-ba88-b539cb11aeb5.png)

6. Из перечисленных выражений для хэш-функций выберите те, которые принадлежат универсальному множеству в соответствии с выражением:

```python
h_ab(k) = ((a*k + b) mod p) mod m
```

где `p` - некоторое простое число; `a` выбирается из диапазона целых значений `{1, ..., p-1}`; `b` - из диапазона целых чисел `{0, ..., p-1}`; `m` - размер хэш-таблицы.

![image](https://user-images.githubusercontent.com/124737857/230786327-9a27796e-9337-4063-8a11-9adcfc17a91a.png)

![image](https://user-images.githubusercontent.com/124737857/230786442-ffe656ef-19cf-4679-91b8-d8fff45b9c28.png)

