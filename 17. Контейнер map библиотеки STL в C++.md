## Контейнер map библиотеки STL в C++

Рассмотрим реализацию карт (`map`) библиотеки `STL` языка `С++`. Контейнер `map` очень похож на контейнер `set` (множества) с тем лишь отличием, что в `map` мы
сохраняем данные в формате «ключ-значение», например, так:

```c++
#include <iostream>
#include <map>
 
int main()
{
         setlocale(LC_ALL, "ru");
         using namespace std;
 
         map<string, int> ar;
 
         ar["do"] = 1;
         ar["to"] = 2;
         ar["dog"] = 3;
         ar["dogs"] = 4;
 
         return 0;
}
```

Здесь вначале подключается заголовок `map` и после этого в функции `main()` становится доступен класс `map`. В угловых скобках прописывается тип для ключа, а затем,
для значения. После этого можно в коллекцию через операторы квадратные скобки (`[]`) добавлять связки «ключ-значение». В программе добавлены четыре таких пары:
`«do=>1»`, `«to=>2»`, `«dog=>3»`, `«dogs=>4»`.

Если указанного ключа не было в коллекции, то он добавляется, иначе, его значение перезаписывается. То есть, ключи в коллекции `map` уникальны и не повторяются.

Также как и `set`, контейнер `map` представляется в виде бинарного дерева, с упорядочиванием вершин по ключам. В частности, для пар `«do=>1»`, `«to=>2»`, `«dog=>3»`,
`«dogs=>4»` дерево будет иметь вид:

![image](https://user-images.githubusercontent.com/124737857/230767688-4c724738-f26f-4a6e-ac94-bc1581442574.png)

Здесь следует учитывать, что строки сравниваются на больше и меньше в лексикографическом порядке. Если теперь вывести ключи этого дерева (коллекции `map`) в консоль:

```c++
for (auto& item : ar)
{
         cout << item.first << endl;
}
```

То увидим их возрастающую последовательность.

Помимо оператора квадратные скобки добавление новой пары ключ-значение можно выполнить с помощью метода `insert`, следующими способами:

```c++
ar.insert(pair<string, int>("do", 1));
ar.insert(make_pair("dos", 3));
```

В первом варианте мы явно формируем объект `pair` с ключом `«do»` и значением `1`, а во втором варианте вызываем вспомогательную функцию `make_pair()` для формирования
того же объекта `pair`. Однако, добавить новую пару ключ-значение удобнее с помощью метода `emplace`:

```c++
ar.emplace("to", 4);
```

здесь попросту указывается ключ и его значение. Кроме того, этот метод работает быстрее, чем метод `insert()`.

Далее, если требуется удалить какой-либо ключ, то для этого можно воспользоваться методом `erase()`:

```c++
auto it = ar.erase("dos");
```

Данный метод возвращает булево значение `false`, если удаление ключа по каким-либо причинам не было выполнено и `true` в противном случае.

Для поиска элемента по ключу используется метод `find()`:

```c++
auto it = ar.find("dos");
```

Данный метод возвращает итератор на пару ключ-значение, если указанный ключ был найден, либо значение `ar.end()`, если ключ не найден.

Вот основные методы при работе с контейнером `map`.

## Задания

1. Выберите верные утверждения для контейнера `map` библиотеки `STL` языка `С++`.

![image](https://user-images.githubusercontent.com/124737857/230768437-50fa6955-d400-4439-858a-5512eea90a1d.png)

![image](https://user-images.githubusercontent.com/124737857/230768464-1fddcbf7-622e-43a4-923c-3042c80e080f.png)

2. Отметьте все команды, которые создают объект класса `map`.

![image](https://user-images.githubusercontent.com/124737857/230768500-0a215f96-97de-4cda-8560-ff9e3a51cd6f.png)

![image](https://user-images.githubusercontent.com/124737857/230768548-e9f01391-044a-40bd-a0ab-dee19a4d7d67.png)

3. На рисунке ниже представлено бинарное дерево для представления элементов коллекции `map`:

![image](https://user-images.githubusercontent.com/124737857/230768571-de8c6fd2-f461-4db9-9190-16bda63e0d3b.png)

В какую позицию 1-6 будет добавлен элемент после выполнения команды:

```python
mp['g'] = 10
```

![image](https://user-images.githubusercontent.com/124737857/230768599-ef05e2c2-ed69-4f2e-8a06-5fa275e2038f.png)

4. Пусть бинарное дерево имеет `n` уровней и в качестве ключей хранит строки. Каков объем вычислений с позиции Big O (О большое) выполнения команды:

```c++
value = mp['key'];
```

![image](https://user-images.githubusercontent.com/124737857/230768638-2ccfc6a4-2541-43ab-8879-4320bb08b143.png)

5. Объявите в программе внутри функции `main()` контейнер `map` с помощью следующей команды:

```c++
std::map<std::string, int> mp;
```

Добавьте в эту коллекцию по порядку следующие пары "ключ-значение":

```
"python"    1
"c++"        2
"php"        3
"java"        4
"javascipt"    5
```

После этого удалите ключ со значением `"javascipt"`.

```c++
#include <iostream>
#include <map>

int main(void)
{
    using namespace std;
    map<string, int> mp;
    
    mp["python"] = 1;
    mp["c++"] = 2;
    mp["php"] = 3;
    mp["java"] = 4;
    mp["javascipt"] = 5;
    
    mp.erase("javascipt");

    return 0;
}
```

6. Объявите в программе внутри функции `main()` контейнер `map` с помощью команды:

```c++
std::map<int, short> mp;
```

Затем, из входного потока прочитайте все данные с помощью следующего фрагмента программы:

```c++
int key, value;
while (!feof(stdin)) {
	cin >> key;
	cin >> value;
	mp[key] = value;
}
```

Выполните проверку наличия в коллекции `mp` ключа со значением 7. Если он присутствует, то выведите в консоль строку `"yes"`, иначе строку `"no"`.

```c++
#include <iostream>
#include <map>

int main(void)
{
    using namespace std;
    map<int, short> mp;
    
    int key, value;
    while (!feof(stdin)) {
        cin >> key;
        cin >> value;
        mp[key] = value;
    }
    
    auto it = mp.find(7);
    
    if (it == mp.cend()) cout << "no";
    else cout << "yes";
    
    return 0;
}
```

7. Вам в программе нужно хранить структуру следующего графа:

![image](https://user-images.githubusercontent.com/124737857/230769358-2c67ce35-2218-43dc-a109-f99342d37ae1.png)

Для этого было решено воспользоваться картами `map`. Поэтому, вам в функции `main()` нужно сделать следующее:

1. Объявить контейнер map командой:

```c++
std::map<short, std::vector<short>> graph;
```

Здесь ключами выступают номера вершин, а значением - динамический массив с номерами вершин, связанных ребром с вершиной ключа.

2. Заполните объект `graph` данными в соответствии с рисунком графа. Номера вершин в динамических массивах должны идти по возрастанию значений.

```c++
#include <iostream>
#include <map>
#include <vector>

int main(void)
{
    using namespace std;
    map<short, vector<short>> graph;
    
    graph[1] = {2, 3, 4};
    graph[2] = {1, 3};
    graph[3] = {1, 2, 5, 6};
    graph[4] = {1, 6};
    graph[5] = {3, 6};
    graph[6] = {3, 4, 5};

    return 0;
}
```
