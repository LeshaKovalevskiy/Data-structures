## Использование хэш-таблиц в Python и С++

### Хэш-таблицы в Python

Когда мы в программе на Python создаем словарь, например:

```python
d = {'one': 1, 'two': 2, 'five': 5}
```

то формируется хэш-таблица с ключами `'one'`, `'two'`, `'five'` и соответствующими значениями 1, 2, 5. Если нам нужно добавить в эту хэш-таблицу еще какой-либо ключ,
то это можно сделать так:

```python
d['three'] = 3
```

А считывание значений по ключу выполняется, например, командой:

```python
value = d['one']
print(value)
```

В качестве ключей словаря должны использоваться только хэшируемые объекты. В Python к ним относятся все неизменяемые типы данных, такие как строки, числа, булевы
значения, кортежи и т.п. А вот если попытаться указать нехэшируемые (изменяемые) объекты, скажем, список:

```python
d[[1,2,3]] = 10
```

то в процессе выполнения этой команды будет сгенерирована ошибка:

```python
TypeError: unhashable type: 'list'
```

По аналогии со словарями в `Python` работает и множество:

```python
s = {'one', 'two', 'five'}
```

Синтаксис очень похож, только здесь как бы фигурируют только ключи (значения множества), а значений у ключей никаких нет. Все эти ключи также сохраняются в
хэш-таблице, образуя значения множества. Отсюда сразу автоматически следует, что значениями множества могут выступать только хэшируемые объекты, например:

```python
s = {'one', (1, 2, 3), True, 10, 5.8}
```

А вот нехэшируемые приводят к той же ошибке, что и у словарей:

```python
s = {'one', (1, 2, 3), True, 10, 5.8, [1, 2, 3]}
```

Здесь последний элемент список (`list`) относится к изменяемому, а значит, нехэшируемому типу.

### Хэш-таблицы в С++

В языке `С++` для использования хэш-таблиц можно воспользоваться классом `unordered_map` стандартной библиотеки шаблонов `STL`. Для этого вначале подключается
заголовок:

```c++
#include <unordered_map>
```

и в функции `main()` получаем возможность создавать объекты (хэш-таблицы) с помощью этого класса:

```c++
int main()
{
         setlocale(LC_ALL, "ru");
         using namespace std;
 
         unordered_map<string, int> ar;
 
         return 0;
}
```

Класс `unordered_map` в целом имеет тот же функционал, что и класс `map`. Только `map` реализован на основе красно-черного бинарного дерева, а `unordered_map` – на
основе хэш-таблиц. Поэтому в программе выбирается тот класс, который предпочтительнее использовать для хранения и обработки данных.

При создании объекта, мы в угловых скобках указываем тип ключа и тип значения. В примере ключ имеет тип `string` (строка), а значение тип `int` (целое число).
Сам объект `ar` представляет собой пустую хэш-таблицу.

Чтобы внести в нее какие-либо данные, можно воспользоваться или методом `insert()`:

```c++
ar.insert(pair<string, int>("one", 1));
ar.insert(make_pair("three", 3));
```

но проще и лучше методом emplace():

```c++
ar.emplace("four", 4);
```

Для перебора содержимого хэш-таблицы удобно использовать цикл `for` следующим образом:

```c++
for (auto& item : ar)
{
         cout << item.first << " " << item.second << endl;
}
```

В результате увидим на экране строчки:

```
one 1
three 3
four 4
```

Также добавлять новые данные можно с помощью оператора квадратные скобки:

```c++
ar["five"] = 5;
```

И читать значения по ключу:

```c++
auto val = ar["one"];
cout << val << endl;
```

Для удаления ключа из хэш-таблицы можно воспользоваться методом `erase()`:

```c++
auto it = ar.erase("three");
```

Данный метод возвращает булево значение `false`, если удаление ключа по каким-либо причинам не было выполнено и `true` в противном случае.

Для поиска элемента по ключу используется метод `find()`:

```c++
auto it = ar.find("two");
```

Данный метод возвращает итератор на пару ключ-значение, если указанный ключ был найден, либо значение `ar.end()`, если ключ не найден.

### Класс unordered_set

Наряду с классом `unordered_map` в библиотеке `STL` языка `С++` есть еще один подобный класс `unordered_set`, который реализует множество на основе хэш-таблиц.
Функционал этого класса подобен функционалу класса `set`.

Чтобы использовать `unordered_set` нужно вначале подключить заголовок:

```c++
#include <unordered_set>
```

А, затем, в функции `main()` создать экземпляр этого класса, например, так:

```c++
int main()
{
         setlocale(LC_ALL, "ru");
         using namespace std;
 
         unordered_set<int> s = { 1, 2, 3 };
 
         for (auto& item : s)
         {
                   cout << item << " " << endl;
         }
 
         return 0;
}
```

Мы здесь сразу инициализируем множество значениями 1, 2, 3. В результате создается хэш-таблица с такими ключами и далее, с помощью цикла `for`, мы перебираем эту
хэш-таблицу и выводим значения ключей в консоль.

Основные методы для работы с классом `unordered_set`:

| Метод | Описание  | Сложность |
| ------| --------- | --------- |
| begin(), cbegin() | Возвращает итератор на первый элемент списка | O(1) |
| end(), cend() | Возвращает итератор на последний элемент списка | O(1) |
| size() | Возвращает число элементов в списке | O(1) |
| insert() | Вставка нового элемента в произвольную позицию | O(1) |
| erase() | Удаление произвольного элемента списка | O(1) |
| find() | Поиск элемента по значению | O(1) |
| clear() | Очистка двусвязного списка | - |
| empty() | Возвращает true, если множество пустое и false в противном случае | O(1) |

Например, мы можем выполнить следующие операции:

```c++
cout << s.size() << endl;
 
s.insert(4);
s.erase(2);
auto it = s.find(1);
if (it != s.end())
{
         cout << *it << endl;
}
```

Главное здесь знать, что `unordered_set` использует хэш-таблицу для хранения и обработки значений, а класс `set` – бинарное красно-черное дерево. Во всем остальном
эти два класса очень похожи.

## Задания

1. Выберите все верные утверждения для множеств (`set`) и словарей (`dict`) языка `Python`.

![image](https://user-images.githubusercontent.com/124737857/230795959-e78773d6-e0e8-4170-b700-dca9e32bfd6d.png)

![image](https://user-images.githubusercontent.com/124737857/230796063-d13fb19c-742f-4ddb-a38b-f32146974ebc.png)

2. Выберите верные варианты создания объекта словаря в `Python`.

![image](https://user-images.githubusercontent.com/124737857/230796079-536e291b-cb66-4c24-8d23-a1076341640d.png)

![image](https://user-images.githubusercontent.com/124737857/230796091-518dbcc2-bbab-467b-8614-8e5dd1639a04.png)

3. Выберите верные варианты записи и считывания данных из словаря `d` в `Python`.

![image](https://user-images.githubusercontent.com/124737857/230796113-7878dda9-caf8-4ba1-bb62-21888a06d61b.png)

![image](https://user-images.githubusercontent.com/124737857/230796120-dbb61212-1453-46d4-ac96-39e1db0980b8.png)

4. Выберите верные варианты создания объекта множества в Python.

![image](https://user-images.githubusercontent.com/124737857/230796129-feeb546e-736e-43ac-95e2-6b13b656152a.png)

![image](https://user-images.githubusercontent.com/124737857/230796145-f1d7f4d0-d2e5-4fdd-a112-c2f63bef2fa8.png)

5. Выберите верные варианты записи и считывания данных из множества `s` в `Python`.

![image](https://user-images.githubusercontent.com/124737857/230796161-ead579d0-a4ce-4fcb-833e-a1c53d11bdd1.png)

![image](https://user-images.githubusercontent.com/124737857/230796170-20e9349e-e47a-4ff9-a191-4ca25e3e313e.png)

6. Программа на `Python`. Пусть имеется следующий словарь:

```python
d = {'one': 1, 'two': 2, 'natural': 1, 'True': 1, 'even': 2, 'three': 3, 'False': 0}
```

Сформируйте из него другой словарь `d_unique`, состоящий из данных с уникальными значениями (оставлять нужно последнее значение, остальные отбрасывать).

```python
d = {'one': 1, 'two': 2, 'natural': 1, 'True': 1, 'even': 2, 'three': 3, 'False': 0}  # этот словарь не менять

d_unique = {k: v for v, k in dict(zip(d.values(), d.keys())).items()}
```

7. Выберите контейнеры множеств и словарей библиотеки `STL` языка `C++`, которые основаны на хэш-таблицах.

![image](https://user-images.githubusercontent.com/124737857/230796238-2673ad8e-6cb2-4ed9-9d8a-19bf7604e10c.png)

![image](https://user-images.githubusercontent.com/124737857/230796261-87116e7a-2e6d-4ef3-b26e-3efd71446b93.png)

8. Объявите в функции `main()` объект `db` с помощью следующей команды:

```c++
std::unordered_map<std::string, short> db;
```

Добавьте в хэш-таблицу db следующие данные, представленные в формате "ключ: значение":

```
"one": 1
"four": 4
"five": 5
"even": 2
```

Затем, удалите из хэш-таблицы `db` ключ `"four"`.

```c++
#include <iostream>
#include <unordered_map>

int main(void)
{
    using namespace std;
    unordered_map<string, short> db;
    
    db["one"] = 1;
    db["four"] = 4;
    db["five"] = 5;
    db["even"] = 2;
    
    db.erase("four");

    return 0;
}
```
