## Бинарные деревья.

Используются в программе, когда нужно хранить и обрабатывать иерархические структуры данных, например, генеалогическое древо семьи, или структура каталогов и файлов и т.п.

То есть, везде, где есть некая начальная (корневая) вершина, от которой можно провести связи к дочерним, а от них – к следующим дочерним, получается иерархическая
древовидная структура.

Начальная вершина дерева, от которого следуют все остальные, называется корнем дерева (`root`). Сами элементы дерева – узлами или вершинами (`nodes`). Причем, узел
слева, называется левым, а справа – правым. Если у вершины нет левого или правого потомка, то обычно указывают значение `NULL`. Вершины, у которых нет потомков,
называются листьями. Само же дерево, у которого каждая вершина может содержать не более двух дочерних узлов, называется бинарным или двоичным.

## Структура бинарного дерева

Чаще всего в практике программирования используют бинарные деревья.

Каждая вершина такого дерева содержит, как минимум, три поля:

 - data – данные, хранимые в вершине дерева;
 - left – ссылка (указатель) на потомка слева;
 - right – ссылка (указатель) на потомка справа.

![image](https://user-images.githubusercontent.com/124737857/230716815-5535a518-2500-4312-8da8-684fb4c56571.png)

Иногда еще добавляют ссылку на родительский узел. Но чаще всего ограничиваются этими тремя полями.

На вершину дерева, которая называется корнем, ведет указатель `root`. И через этот указатель происходит вся работа с бинарным деревом: добавление/удаление элементов;
обход всех узлов дерева. То есть, из корневого узла можно пройти до любого другого в данном дереве. При этом, количество вершин, через которые нужно пройти, чтобы
достичь некоторого узла, определяет уровень (`level`) дерева. Если дерево не содержит ни одной вершины, то `root = NULL`. Также, если у какой-либо вершины отсутствует
левый или правый потомок, то соответствующий указатель принимает значение `NULL`.

## Добавление вершин в бинарное дерево

Обычно, новые узлы добавляются к свободному указателю (то есть, тот, который принимает значение `NULL`), начиная с корневого. То есть, первая вершина всегда
добавляется в корень, и других вариантов просто нет. А вот далее, мы уже решаем добавить левый или правый узел. Строго говоря, ограничений здесь никаких нет.
Алгоритм добавления может быть самым разным, исходя из поставленной задачи. 

Например, если нам нужно сформировать генеалогическое древо, то, очевидно, в вершинах последовательно должны указываться потомки: на нулевом уровне – некоторый
человек; на первом – мама, папа; на втором – бабушки, дедушки и т.д. 

Но есть отдельный класс задач, когда в вершинах бинарного дерева хранятся данные, которые можно сравнивать на больше и меньше (например, числа), и добавление нового
узла происходит по правилам:

 - если добавляемое значение меньше значения в родительском узле, то новая вершина добавляет в левую ветвь, иначе – в правую;
 - если добавляемое значение уже присутствует в дереве, то оно игнорируется (то есть, дубли отсутствуют).

Например, предположим, мы собираемся хранить в вершинах бинарного дерева целые числа. И будем последовательно добавлять узлы для значений:

```
10, 5, 7, 16, 13, 2, 20
```

Первое значение 10 просто добавляется в корневую вершину. Следующее значение 5. Смотрим от корня. Пять меньше 10. Тогда, согласно нашим правилам, это значение нужно
записать в левую ветвь. Формируем новый узел со значением 5. Следующее значение 7. Снова идет от корня дерева. Семь меньше 10, переходим в левую ветвь. Здесь у нас
узел со значением 5. И семь больше 5. Следовательно, семь нужно добавить в качестве правого узла дерева у вершины 5. Далее, идет число 16. Оно больше 10, поэтому
добавляем его в качестве правой вершины у корневой. И так далее получаем:

![image](https://user-images.githubusercontent.com/124737857/230716982-bda32ca0-5071-4598-9814-b4baff50632d.png)

Благодаря такому подходу в формировании бинарного дерева, у нас в левой ветви будут находиться вершины со значениями меньше, чем у корневой, а в правой ветви – 
вершины со значениями больше корневой. И этот вывод будет справедлив для любого выделенного фрагмента поддерева, например:

![image](https://user-images.githubusercontent.com/124737857/230717045-b981fcb4-6a7a-4bb0-b502-0e81c1f3fdc6.png)

## Поиск значений в бинарном дереве

Бинарное дерево ускоряет поиск заданного значения. Например, нам нужно определить, находится ли число `2` в последовательности
чисел `10, 5, 7, 16, 13, 2, 20`. Если бы мы хранили числа в обычном массиве то время поиска, с точки зрения O большого, составило бы `O(n)`, где `n` – число элементов в
массиве. Нам пришлось бы последовательно перебирать все элементы и сравнивать значения с числом `2`.

А вот в бинарном дереве все несколько иначе и, в среднем, быстрее. Вначале число `2` сравнивается с числом `10`. Оно меньше, поэтому идем по левой ветви, где
сосредоточены вершины со значениями меньше `10`. В результате, мы сразу отсекаем правую группу элементов, значения которых заведомо не равны `2`. За счет этого происходит
ускорение поиска. Затем, сравниваем `2` и `5`. И, так как `2` меньше `5`, то снова переходим по левой ветви. Находим заданное значение.

С позиции О большого среднее число операций, необходимое для поиска нужного значения составляет $O(log{_2}{n})$. И это значительно быстрее, чем линейный поиск в
массивах или связных списках.

Посмотрим на работу алгоритма в случае, когда заданное значение для поиска в бинарном дереве отсутствует. Например, это число `11`. Идем сначала
по правой ветви, в узле `16` – по левой, и доходим до листовой вершины `13`. Далее, никаких узлов в дереве нет, но значение не было найдено, следовательно, в дереве
нет `11`.

## Сбалансированные и несбалансированные деревья

Если бы числа при формировании дерева поступали в другом порядке, или по возрастанию:

```
2, 5, 7, 10, 13, 16, 20
```

или по убыванию:

```
20, 16, 13, 10, 7, 5, 2
```

то деревья выглядели бы совсем иначе:

![image](https://user-images.githubusercontent.com/124737857/230717551-7c186bad-44fb-4870-856f-cdb08843f947.png)

Фактически, они вырождаются в односвязный список и объем вычислений для поиска заданного значения в них составляет `O(n)`. Так же, как и в обычных массивах или
связных списках.

Такие вырожденные деревья (и подобные им) называются несбалансированными. В отличие от первого, которое относится к сбалансированным.

Вообще, дерево называется **сбалансированным**, если в нем поддеревья от одной вершины отличаются не более чем на один уровень. И именно в сбалансированных деревьях
поиск значений в вершинах выполняется за минимальное число шагов с объемом вычислений `O(log n)`. Поэтому, на практике, стремятся строить деревья близкие к
сбалансированным. Для этого используют методы балансировки двоичных деревьев, среди которых, наиболее известны следующие:

 - АВЛ-дерево (AVL tree);
 - красно-черное дерево (red-black tree);
 - расширяющееся или косое дерево (splay tree).

Любой из этих методов может быть реализован в бинарном дереве и вызываться при добавлении новых вершин. В результате получаем более сбалансированное дерево при
любых входных последовательностях данных. 

Если нам известно, что в решаемой задаче данные (значения) поступают в случайном порядке, то в среднем, будет формироваться бинарное дерево близкое к сбалансированному.

## Задания

1. На рисунках `а-г` показаны различные структуры бинарных деревьев. Отметьте те из них, которые являются сбалансированными.

![image](https://user-images.githubusercontent.com/124737857/230717991-0aa7822d-d5a2-4311-8378-f57cabc40855.png)

![image](https://user-images.githubusercontent.com/124737857/230718022-2712aacb-6824-4a48-8f23-722ffd67d4bc.png)

2. На рисунке показана общая структура бинарного дерева:

![image](https://user-images.githubusercontent.com/124737857/230718041-db225e46-c073-4aef-8669-6f61e8cb1ca8.png)

Отметьте все верные утверждения, связанные с этой структурой.

![image](https://user-images.githubusercontent.com/124737857/230718053-cef58ffd-4a11-4551-ba61-5ece21887046.png)

![image](https://user-images.githubusercontent.com/124737857/230718085-5c0e3c52-8a30-4355-bee3-c92a301659a3.png)

3. Пусть данные, которые мы собираемся хранить в бинарном дереве, могут сравниваться на больше и меньше. Сами же данные будут заноситься в вершины бинарного дерева
согласно следующему алгоритму:

 - если добавляемое значение меньше значения в родительском узле, то новая вершина добавляет в левую ветвь, иначе – в правую;
 - если добавляемое значение уже присутствует в дереве, то оно игнорируется (то есть, дубли отбрасываются).

Отметьте все преимущества, которые дает такое бинарное дерево.

![image](https://user-images.githubusercontent.com/124737857/230718220-8e03f930-3039-4a71-b389-53a435fa502d.png)

![image](https://user-images.githubusercontent.com/124737857/230718236-7e8634f9-d6ad-453f-a01b-162ad4f854be.png)

## Способы обхода и удаления вершин

Существует два основных подхода обхода вершин деревьев:

 - в ширину (breadth-first);
 - в глубину.

При обходе в ширину, перебор узлов дерева выполняется по уровням слева направо. При обходе в глубину сначала доходят до листовой вершины, а затем, переходят к
следующей ветви.

## Алгоритм обхода в ширину

Имеется двухуровневое бинарное дерево:

![image](https://user-images.githubusercontent.com/124737857/230733196-bfdcf001-4e49-4c71-bcf2-73110eb345b6.png)

На корневую вершину ведет указатель `root`. Создадим еще один вспомогательный указатель `p` на эту же вершину:

```python
p = root
```

и список из вершин текущего уровня в порядке слева-направо:

```python
v = [p]
```

Изначально в списке только одна корневая вершина. Сформируем два цикла: первый будет работать, пока список вершин не пуст, то есть, пока в дереве имеются узлы
текущего уровня; а второй будет перебирать вершины текущего уровня, выводить информацию на экран и формировать список следующего уровня:

```python
while v:
    vn = []
    for x in v:
        print(x.data)
        if x.left:
            vn += [x.left]
        if x.right:
            vn += [x.right]
    v = vn
```    
   
В результате, сначала будет выведено значение 7 корневого узла. Затем, сформирован список `vn` из двух узлов следующего уровня в порядке слева-направо. После этого
списку `v` присваивается новый сформированный список `vn` следующего уровня и на следующей итерации цикла `while` во вложенном цикле `for` будут перебираться уже
вершины первого уровня. На экран выведутся значения 2 и 5. Снова сформируется список `vn` из вершин следующего второго уровня. И на следующей итерации цикла `while`
будут выведены значения 3, 4 и 6. После этого список `vn` окажется пустым, следовательно, список `v` также будет пустой и цикл `while` завершит свою работу.

## Алгоритм обхода в глубину

Следующий тип алгоритмов – это обход дерева в глубину. Здесь мы проходим по определенной ветви до листовой вершины. Пусть у нас то же самое бинарное дерево. Начальная
вершина, как всегда, корневая (`root`). Затем, мы должны для себя решить, по какой из двух ветвей идти в первую очередь, а по какой – во вторую. Например, сначала по
левой ветви, а затем, с возвратами проходить правые ветви. Это можно реализовать следующей рекурсивной функцией:

```python
def show_tree(self, node):
    if node is None:
        return
 
    self.show_tree(node.left)
    print(node.data)
    self.show_tree(node.right)
```    
    
С начальным вызовом от корневой вершины:

```python
show_tree(root)
```

Мы начинаем двигаться от корневого узла. Если он существует, то вызывается та же самая функция для левого узла. В результате, мы как бы попадаем в ту же самую функцию,
только параметр `node` теперь является ссылкой на узел со значением 3. Здесь выполняется та же самая проверка: если узел существует, то по рекурсии мы снова переходим
к следующему левому узлу. Это узел со значением 2. Снова делается проверка на его существование и, так как он существует, переходим к следующему левому узлу. Теперь
параметр `node` принимает значение `None`, рекурсия завершается и мы возвращаемся к прежнему вызову с параметром `node` узла 2. Это значение отображается на экране и
делается попытка пройти по правой ветви. Так как справа объектов нет, то вызов текущей функции завершается и мы попадаем в функцию уровнем выше с параметром `node` на
узел 3. Это значение 3 выводится на экран и делается попытка пройти по правой ветви. Ее нет, поэтому мы возвращаемся на уровень выше, то есть, к корневому узлу со
значением 5. Это значение выводится на экран и далее аналагичным образом обходится правая ветвь. В итоге имеем:

```
2, 3, 5, 6, 7, 8
```

При обходе дерева в глубину в порядке левое поддерево (`L`); промежуточная вершина (`N`); правое поддерево (`R`) получается возрастающая последовательность.

Сокращенно такой алгоритм в глубину получил название `LNR`.

А если пройти сначала по правой ветви, затем вывести значение промежуточной вершины, а после пройти по левой ветви, то получим убывающую последовательность:

```
8, 7, 6, 5, 3, 2
```

Такой алгоритм сокращенно называется `RNL`.

Комбинируя различные варианты обхода и отображения значений вершин можно получать самые разнообразные вариации алгоритмов обхода в глубину.

## Удаление вершин бинарного дерева

1) Удаление листовых вершин

Самый простой случай, когда удаляется листовой узел дерева. Предположим, что это узел 23:

![image](https://user-images.githubusercontent.com/124737857/230733809-fe0351f8-05f7-4f9f-a64b-c78f7cd6f9a4.png)

Тогда, нам достаточно получить указатель `p` на родительский узел и указатель `s` на удаляемый узел. После этого ссылку, ведущую на удаляемый узел следует приравнять
`NULL` и освободить память из под узла `s`:

```python
p.left = NULL
delete s
```

2) Удаление узла с одним потомком

Например, нам нужно удалить узел 5, у которого один потомок справа:

![image](https://user-images.githubusercontent.com/124737857/230733887-8a1e89bb-bc93-404d-84ae-60cb97fd5e1b.png)

Здесь мы также должны иметь два указателя: `p` – на родительскую вершину; `s` – на удаляемую вершину. Затем, исключаем из дерева удаляемую вершину 5, меняя связь от
родительской вершины 20 к вершине 16 (которая идет после удаляемой):

```python
p.left = s.right
delete s
```

Причем, ситуация принципиально не меняется, если у удаляемой вершины один правый или левый потомок. Алгоритм удаления таких вершин работает похожим образом.

3) Удаление узла с двумя потомками

Общая идея здесь такая. Сам узел не удаляется, меняется только его значение на новое. А новое берется как наименьшее из правой ветви. Например, если мы хотим удалить
узел 5, то следует взять наименьшее значение 16 из правого поддерева. Записать его вместо 5, а листовой узел 16 просто удалить:

![image](https://user-images.githubusercontent.com/124737857/230733940-acb32adb-0fe9-41ed-b4b0-8896f197e660.png)

Что если справа имеется полноценное поддерево с множеством вершин?

Идея алгоритма остается прежней. Выбираем узел с наименьшим значением 11 в правом поддереве, заменяем 5 на 11 и удаляем листовой узел 11:

![image](https://user-images.githubusercontent.com/124737857/230734022-761bac6f-fe7a-4bf7-a2c2-20706e682ee7.png)

Но вершина с наименьшим значением в правом поддереве не всегда является листовой. Возможны и такие ситуации:

![image](https://user-images.githubusercontent.com/124737857/230734043-b916468a-c344-4539-b552-c17138d04617.png)

Однако можно заметить, что у узла с наименьшим значением может быть только один потомок справа. А значит, его удаление будет выполняться по алгоритму удаления вершин с одним потомком. Например, рассмотрим второе дерево. Нам потребуется три указателя: t – на удаляемую вершину (то есть, вершину, у которой будет меняться значение); s – на вершину с наименьшим значением в правом поддереве; p – на родительскую вершину для вершины s:

![image](https://user-images.githubusercontent.com/124737857/230734059-dbd1d2af-3fe6-491e-881a-ba40b0354983.png)

Затем, мы меняем значение вершины 5 на 11:

```python
t.data = s.data
```

и производим удаление вершины 11 согласно алгоритму удаления вершин с одним потомком:

```python
p.left = s.right
delete s
```

В результате получаем дерево:

![image](https://user-images.githubusercontent.com/124737857/230734069-453072db-272e-4448-be86-e391b25cb1d4.png)

Вот основные типовые варианты удаления вершин в бинарном дереве:

 - удаление листового узла;
 - удаление узла с одним потомком (правым или левым);
 - удаление узла с двумя потомками.
 
 ## Задания
 
 1. На рисунке ниже представлено бинарное дерево, в узлах которого хранятся целые числа:

![image](https://user-images.githubusercontent.com/124737857/230735026-63733c05-2bf1-4a54-a3f1-5428486af1a4.png)

В каком порядке будут выведены числа следующим алгоритмом обхода его вершин в ширину:

```python
p = root
v = [p]

while v:
    vn = []
    for x in v:
        print(x.data)
        if x.right:
            vn += [x.right]
        if x.left:
            vn += [x.left]
    v = vn
```

![image](https://user-images.githubusercontent.com/124737857/230735074-132f06c5-61f7-421e-8f0c-907cbea04700.png)

2. На рисунке ниже представлено бинарное дерево, в узлах которого хранятся целые числа:

![image](https://user-images.githubusercontent.com/124737857/230735091-3a7bdd44-c9b3-4d26-823a-87dd2bd09484.png)

В каком порядке будут выведены числа следующим алгоритмом обхода его вершин в глубину:

```python
def show_tree(self, node):
    if node is None:
        return
 
    self.show_tree(node.right)
    print(node.data)
    self.show_tree(node.left)


show_tree(root)
```

![image](https://user-images.githubusercontent.com/124737857/230735115-c9b0be39-5ddb-422c-8230-133d240c9b4e.png)

3. На рисунке ниже представлено бинарное дерево, у которого нужно удалить вершину с одним (левым) потомком:

![image](https://user-images.githubusercontent.com/124737857/230735398-20d04a04-0261-4a28-9f5c-2f28351b1aed.png)

На удаляемую вершину ведет ссылка `s`, а на ее родительскую - ссылка `p`. Выберите правильную последовательность команд для удаления вершины `s`.

![image](https://user-images.githubusercontent.com/124737857/230735418-58ae6b50-4e3e-4613-a18a-a232f127f89e.png)

![image](https://user-images.githubusercontent.com/124737857/230735433-3e353498-d74f-49d9-a5cf-89960f107812.png)

4. На рисунке ниже представлено бинарное дерево, у которого нужно удалить вершину с двумя потомками:

![image](https://user-images.githubusercontent.com/124737857/230735475-927fc89c-d0d5-4c43-9039-6c5a4f86f140.png)

На удаляемую вершину ведет ссылка `t`; `s` – на вершину с наименьшим значением в правом поддереве; `p` – на родительскую вершину для вершины `s`. Выберите
правильную последовательность команд для удаления вершины `t`.

![image](https://user-images.githubusercontent.com/124737857/230735548-82951a86-1c10-4f31-b951-ac25ba157e31.png)

![image](https://user-images.githubusercontent.com/124737857/230735559-d1a7914a-bd0f-4e24-97cd-2ca10449e676.png)

5. На рисунке ниже представлено бинарное дерево, у которого нужно удалить вершину с двумя потомками:

![image](https://user-images.githubusercontent.com/124737857/230735687-b7928b7f-a7af-4d67-8ac9-f6141223d161.png)

На удаляемую вершину ведет ссылка `t`; `s` – на вершину с наименьшим значением в правом поддереве; `p` – на родительскую вершину для вершины `s`. Выберите 
правильную(ые) последовательность(и) команд для удаления вершины `t`.

![image](https://user-images.githubusercontent.com/124737857/230735733-d5e3cf28-32d9-4746-894b-5d460449e9b1.png)

![image](https://user-images.githubusercontent.com/124737857/230735746-905c709f-9346-4e97-b03b-07975e152e69.png)

6. На рисунке ниже представлено бинарное дерево, у которого нужно удалить вершину с двумя потомками:

![image](https://user-images.githubusercontent.com/124737857/230735962-7ac56311-e101-46a1-96c5-18bd9b6af7e2.png)

На удаляемую вершину ведет ссылка `t`; `s` – на вершину с наименьшим значением в правом поддереве; `p` – на родительскую вершину для вершины `s`. Выберите 
правильную(ые) последовательность(и) команд для удаления вершины `t`.

![image](https://user-images.githubusercontent.com/124737857/230736010-86156aad-4aa5-4216-aa0f-086375eae14b.png)

![image](https://user-images.githubusercontent.com/124737857/230736026-d81617aa-db30-4846-ac0e-e84c92722201.png)
