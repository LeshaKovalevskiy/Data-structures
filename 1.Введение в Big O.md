## 1.Введение в Big O

**Примеры структур данных**:
 - статический и динамический массивы;
 - стек;
 - очередь;
 - односвязный и двухсвязный списки;
 - множество;
 - хэш-таблица;
 - деревья; бинарные деревья.

Оценка скорости алгоритмов:
 1. По числу элементарных арифметических операций(подходит для простых и математических алгоритмов).
 2. Фактическое время выполнения(зависит от "железа" и скорости возрастания алгоритмов).
 3. Верхняя граница динамики изменения вычислительной сложности алгоритма, в зависимости от размера входных данных(Big O(O-большое)). 

### Сложность константных операций:

![image](https://user-images.githubusercontent.com/124737857/227601124-fad685d9-4be7-470c-9386-56321cb676b2.png)

В каждой строчке выполняется одна операция за одно и то же константное время. В нотации О большого это записывается так: **O(1)**

При качественном сравнении скорости работы алгоритмов подобные константы не имеют большого значения. То есть, с точки зрения О большого любая константа может быть отброшена. 

Например:

 - O(10) = O(1)

В общем случае:
 - O(C) = O(1), здесь C – константа. 

### Линейная сложность выполнения алгоритма

![image](https://user-images.githubusercontent.com/124737857/227601670-9b6eba5b-4655-4a03-b4c1-574895c7dfa6.png)

![image](https://user-images.githubusercontent.com/124737857/227601705-2b794e9c-d7ae-4cff-9d68-be3f1b3df0a3.png)

Число итераций цикла зависит от размерности массива n. Чем больше n, тем больше итераций нужно сделать в цикле. То есть, цикл зависит от размера входных данных. 

В данном случае эта величина равна: **O(n)**

Константы так же отбрасываются:
 - O(2n) = O(n)
 - O(n + 1) = O(n)

В общем случае:
 - O(A∙n) = O(n)
 - O(n + C) = O(n)
 - O(A∙n + C) = O(n), где A, C – константы; n – размер (число) входных данных.

### Правила сложения и умножения

![image](https://user-images.githubusercontent.com/124737857/227602319-8bead46e-6ec4-4b42-8253-90b2943575ff.png)

Вычислительная сложность алгоритма с точки зрения Big O будет равна:

O(n) + O(m) = O(n + m)

Далее, если мы один цикл запишем внутри другого:

![image](https://user-images.githubusercontent.com/124737857/227602411-9bfcf1c9-2a67-4ebf-8f57-e0d519cc85e6.png)

то объем вычислений в нотации О большого примет вид: O(n * m).

## Неважная сложность

После вложенного цикла добавим еще один цикл:

![image](https://user-images.githubusercontent.com/124737857/227604687-96dba2bf-a3a9-4856-b656-325fba1924dd.png)

Формально, Big O для этого случая можно записать в виде: O($n^2$ + n)

Cлагаемое n значительно меньше при n -> $\infty$. И с точки зрения Big O оно становится не значимым, а значит, может быть отброшено. 

Поэтому результат запишется так: O($n^2$)

Если одно слагаемое может принимать значения более чем в два раза больше другого, значит, оно значимое. Соответственно, второе – незначимое.

## Алгоритмы с логарифмической сложностью

Довольно часто на практике можно столкнуться с алгоритмами, имеющими логарифмическую сложность выполнения. Яркий представитель – бинарный поиск.

![image](https://user-images.githubusercontent.com/124737857/227605605-e3d7aeb3-0fc6-4869-b054-41a964d2fd26.png)

## Алгоритмы с факториальной сложностью

Следующий распространенный класс алгоритмов – это, так называемые, NP-полные задачи, в которых приходится делать полный перебор всех вариантов, чтобы найти искомое решение. Например, мы хотим написать алгоритм по сборку пазла. В самом простом случае, можно перебрать все возможные варианты из фрагментов и выбрать нужный.

Другой похожий алгоритм, который часто приводят в качестве примера NP-полной задачи – это решение задачи коммивояжера. В ней необходимо выстроить наикратчайший маршрут из некоторой начальной точки, проходящий через все города.

Это одни из самых сложных алгоритмов (в вычислительном плане). Как только мы получаем такую оценку сложности, есть смысл подумать о более простых подходах, дающие пусть и не точное, но близкую к точному решение. Конечно, если n в задачах можеть быть от 10 и более.

## Порядок возрастания вычислительной сложности алгоритмов

![image](https://user-images.githubusercontent.com/124737857/227606022-bc407dee-c501-47ff-9407-ae5cc6be5daf.png)

## Задания из курса:

1. Что показывает характеристика "О большое"?

![image](https://user-images.githubusercontent.com/124737857/227607495-12585af7-c94b-42ac-82c4-2ace4d3e908f.png)

![image](https://user-images.githubusercontent.com/124737857/227607586-4c3048ae-9750-41ca-8a73-18dcc1cbc367.png)

2. Производится копирование файла с фиксированной скоростью из одного каталога в другой. Размер файла может быть произвольным и составлять N байт. Какова вычислительная сложность этого процесса с позиции Big O (О большое)?

![image](https://user-images.githubusercontent.com/124737857/227607722-081fa775-9c89-4afc-a107-737acecafa83.png)

3. Пусть имеется следующая программа на Python:

```
msg = "Курс по структурам данных"
print(msg)
```

Какова вычислительная сложность этой программы с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227608532-17c01238-afeb-4b20-8f30-5a040b1f0113.png)

4. Имеется программа отображения в консоль значений половины элементов массива lst длины N:

```
for i in range(N // 2):
    print(lst[i])
```

Какова вычислительная сложность этой программы с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227608823-9bba99e8-b8d1-4740-be28-6d38fcdac0fa.png)

5. В программе на Python происходит отображение на экран двух последовательностей длинами n:

```
n = int(input("Введите значение n: "))

for x in range(n):
    print(x)

for x in range(n):
    print(x ** 2)
```

Какова вычислительная сложность этой программы с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227609087-cd483964-4f56-44a7-9a21-c21430f910fa.png)

6. Имеется следующая программа на Python:

```
m = int(input("Введите значение m: "))

for x in range(m):
    for y in range(m):
        print(x * y)
```

Какова вычислительная сложность этой программы с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227609334-5b8257d9-1478-47db-be29-9b71612a92f9.png)


7. Пусть A, C - константы. Выберите правильный результат конечного преобразования выражения O(C^2 + A).

![image](https://user-images.githubusercontent.com/124737857/227609456-937fe18c-498c-4a0c-b378-fe98be5cb0c6.png)

8. Выберите правильный вариант упрощения записи Big O (О большого) записанного в виде: O(A + n + $n^2$)

где A - константа; n - переменная.

![image](https://user-images.githubusercontent.com/124737857/227609940-209119ad-9091-4e66-b108-983f21b1f812.png)


9. Имеется программа на языке Python:

```
lst = [0] * n   # список из n нулей
for i in range(n):
    lst[i] = i % 5

for i in range(n):
    for j in range(m):
        lst[i] += lst[j]
```

Какова вычислительная сложность этой программы с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227610330-554702e8-ff57-4172-becf-3d296f7d73b7.png)

10. Имеется сбалансированное бинарное дерево с n вершинами (n - переменная величина), сформированное по правилу: если числовое значение меньше значения в вершине, то оно добавляется в левое поддерево, а иначе - в правое. На рисунке ниже представлен пример такого бинарного дерева:

![image](https://user-images.githubusercontent.com/124737857/227610476-ad805b2b-019a-43c2-b59f-cd8371675cc8.png)

Для таких деревьев реализован алгоритм поиска некоторого значения x. Поиск начинается с корня (самой верхней вершины дерева). Если x не равен значению в вершине, то при x меньше, чем значение в вершине, поиск продолжаем в левом поддереве, иначе - в правом. Так как каждое поддерево - это такое же полноценное бинарное дерево, то для них процедура поиска полностью повторяется пока либо не найдется заданное значение x, либо не дойдем до листовой вершины (у которой нет потомков).

Оцените сложность этого алгоритма с точки зрения О большого.

![image](https://user-images.githubusercontent.com/124737857/227610589-3a7b42e4-0b70-4886-b51e-0a88aa91ba07.png)


11. Имеется следующая программа на языке Python, вычисляющая произведение двух квадратных матриц A и B размерностью n x n и результат сохраняется в третью матрицу C также размерами n x n:

```
for i in range(n):
    for j in range(n):
        s = 0
        for k in range(n):
            s += A[i][k] * B[k][j]
        C[i][j] = s
```

Какова вычислительная сложность этой программы с позиции Big O?

![image](https://user-images.githubusercontent.com/124737857/227610771-3e9f5377-eb28-4b44-877d-09053458bb19.png)
