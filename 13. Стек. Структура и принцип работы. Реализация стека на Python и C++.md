## Стек. Структура и принцип работы

Идея стека состоит в организации данных по принципу очереди `LIFO` (`Last in`, `First Out`): последним вошел, первым вышел. Например, так можно организовать историю
посещения страниц в браузере для определенной вкладки.

![image](https://user-images.githubusercontent.com/124737857/230656462-7df0ef95-081f-402a-bcca-0bdf8efaaaf8.png)

Стек – это организация данных по принципу очереди `LIFO`. Но небольшое отличие, правда есть. Функционал стека позволяет только читать значение верхнего элемента,
добавлять/удалять только элементы сверху. Например, перейти к произвольному элементу стека и получить его значение уже не получится. Тогда, как в очередях такая
возможность имеется. То есть, стек – это все та же очередь, но с более ограниченным функционалом.

На практике встречается довольно много задач, где данные удобно представлять в виде стека и при этом не предполагается произвольный доступ к другим элементам и работа
с ними.

Поэтому, чтобы в программе подчеркнуть, что используется именно стек, а не просто очередь `LIFO` и выделили отдельно эту структуру данных.

В программах стек (равно, как и очереди) часто реализуют на базе односвязного или двусвязного списка. На вершину стека ссылается указатель `top`. Через него и
выполняется обработка элементов стека. Однако стек можно реализовать на основе любых других подходящих структур данных, например, динамического массива с добавлением
и удалением последних элементов:

![image](https://user-images.githubusercontent.com/124737857/230657022-a3afcef3-290f-44cd-bc73-0d421945e08f.png)

В результате, стек можно рассматривать, как некую абстрактную структуру данных, в которой возможна работа только с верхним (последним) элементом, и которая может быть
реализована на базе любой подходящей (не абстрактной) структуры данных (связные списки, динамические массивы).

## Примеры использования стека

Cамый распространенный случай – это стек вызова функций:

```python
def main():
    a = 5
    print("a = " + str(a))
    b = 4
```    
    
Cначала вызывается функция `main()`, затем она вызывает функцию `print()`. Причем, обе функции в момент вызова продолжают работать. Затем, завершается функция `print()`
и только потом – функция `main()`. Чтобы программа «знала» в каком порядке были вызваны функции и в каком порядке их следует завершать, как раз и используется стек
вызова функций. В момент вызова функции `main` она помещается наверх стека. Затем, когда очередь доходит до функции `print`, эта функция помещается наверх стека.
После отработки функции `print`, она извлекается из стека, т.к. находится на самом верху. А после завершения функции `main` стек становится пустым.

Следующий пример – анализ данных с помощью стека. Предположим, у нас записано некоторое математическое выражение:

```python
78 * (23 - 7 * (1 - 4)) + (95 / 5)
```

и требуется выделить фрагменты во всех круглых скобках. Один из эффективных подходов – воспользоваться стеком. Вначале мы посимвольно анализируем выражение. И как
только встречается открывающаяся круглая скобка, то записываем ее индекс в стек. Далее, встречается следующая открывающаяся круглая скобка. Снова заносим ее индекс в
стек. Идем дальше по строке и видим закрывающуюся круглую скобку. В этом случае извлекаем из стека верхний объект, читаем значение индекса и выделяем фрагмент (срез)
в диапазоне индексов `[start+1:end)`. Для следующей закрывающейся круглой скобки делаем то же самое, но с очередным верхним объектом стека. В результате у нас
выделяются нужные фрагменты.

Часто там, где возникает некая иерархия работы алгоритма, удается эффективно решить задачу с использованием стека.

## Методы стека

Основные методы, которые поддерживаются стеком:

|Метод|Описание|Сложность|
|-----|--------|---------|
| top() | Возвращает значение верхнего элемента стека | O(1) |
| push() | Добавляет новый элемент на вершину стека | O(1) |
| pop() | Удаляет элемент с вершины стека | O(1) |
| size() | Возвращает число элементов в стеке | O(1) |
| empty() | Возвращает True, если стек пуст, и False в противном случае | O(1) |

## Задания

1. Выберите все верные утверждения для стека (`stack`).

![image](https://user-images.githubusercontent.com/124737857/230658157-46f0bb53-170f-49bc-be65-2c944e17085b.png)

![image](https://user-images.githubusercontent.com/124737857/230658218-27c8d182-4ed2-4b16-bdf1-3252933ae7d8.png)

2. Каждый элемент стека состоит из 24 байт. В стеке 5 таких элементов. Сколько байт памяти занимают все пять элементов стека?

![image](https://user-images.githubusercontent.com/124737857/230658342-12933c3a-451f-4deb-8fae-b5c0ac6e5185.png)

## Реализация стека на Python и C++

Довольно часто стек делают с использованием списка(динамического массива):

```python
stack = []
 
stack.append(1)
stack.append(2)
 
value = stack.pop()
```

Однако такая реализация будет не самым лучшим вариантом, так как добавление элементов в конец динамического массива может потребовать создания его новой копии,
если физического размера текущего массива недостаточно. 

Если в стеке могут содержаться сотни и тысячи элементов, то лучшим вариантом будет использование специального объекта `deque` (очереди) из модуля `collection`:

```python
from collections import deque
```

`deque` основан на двухсвязных списках, то есть, каждый элемент хранит ссылку на следующий элемент и предыдущий элементы. В результате, операции
добавления и удаления новых элементов в начало или конец очереди всегда выполняется за одно и то же число операций `O(1)`.

Использовать очередь в качестве стека очень просто. Вначале создается объект класса `deque`:

```python
stack = deque()
```

или же с некоторым начальным набором данных:

```python
stack = deque([1, 2, 3])
```

А, затем, с помощью метода `append()` добавляется новый элемент в конец очереди (вершину стека):

```python
stack.append(4)
stack.append(5)
```

Для удаления последнего элемента (с вершины стека) используется метод `pop()`:

```python
print(stack.pop())
print(stack.pop())
print(stack.pop())
```

Теперь посмотрим, как реализуется стек на языке `С++`. В стандартной библиотеке шаблонов `STL` уже имеется объект, отвечающий за стек. Чтобы им воспользоваться,
достаточно подключить библиотеку с именем stack:

```c++
#include <stack>
```

И, затем, в программе создать объект класса `stack` следующим образом:

```c++
int main()
{
         using namespace std;
         stack<int> st;
 
         return 0;
}
```

Затем, через объект `st` мы можем вызывать различные методы стека. Для добавления нового элемента в начало стека используется метод `push()`, например:

```c++
st.push(1);
st.push(2);
st.push(3);
```

Если нужно прочитать значение самого верхнего элемента, используется метод `top()`:

```c++
cout << st.top() << endl;
```

Для удаления верхнего элемента применяется метод `pop()`:

```c++
st.pop();
```

Или же мы можем в цикле выполнять удаления элементов, пока стек не станет пустым:

```c++
while (!st.empty()) {
    cout << st.top() << endl;
    st.pop();
}
```

Однако, на самом деле, объект `stack` в стандартной библиотеке языка `С++` - это, надстройка над другой коллекцией данных. По умолчанию – над очередью:

```c++
#include <deque>
```

Но при желании можно указать другие коллекции, например, динамический список:

```c++
#include <vector>
```

и создать объект:

```c++
stack<int, vector<int>> st;
```

или двухсвязный список:

```c++
#include <list>
stack<int, list<int>> st;
```

Однако использование очереди `deque` является предпочтительным выбором. Именно поэтому данная коллекция используется по умолчанию.

## Задания

1. Используя класс `deque` из модуля `collections`, необходимо реализовать стек, добавляя и извлекая элементы с начала очереди (слева).

Создайте в программе объект класса `deque` с именем `st` без элементов. Добавьте в стек `st` последовательно значения из списка `lst_in`, прочитанные из входного
потока следующей командой:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

Извлеките один элемент из стека `st` и выведите его значение на экран.

```python
import sys
from collections import deque

lst_in = list(map(str.strip, sys.stdin.readlines()))  # этот список в программе не менять

st = deque()
for el in lst_in:
    st.appendleft(el)

print(st.popleft())
```

2. Ниже представлена программа на `Python`, использующая идею стека для выделения выражений в круглых скобках математических формул:

```python
def get_sub_eq(eq_str):
    st = []
    res = []

    for i, x in enumerate(eq_str):
        if x == "(":
            st.append(i)
        elif x == ")":
            res.append(eq_str[st.pop()+1: i])

    return res

s = "2 + 3 * (1 - 5 - (3 * x - 5)) + (a - b)"
res = get_sub_eq(s)
```

Изучите эту программу и модифицируйте ее с использованием очереди `deque` вместо списка `st`. Кроме того, добавьте возможность выделения выражений в квадратных
скобках.

```python
from collections import deque


def get_sub_eq(eq_str):
    st = deque()

    res = []

    for i, x in enumerate(eq_str):
        if x in ("(", "["):
            st.append(i)
        elif x in (")", "]"):
            res.append(eq_str[st.pop() + 1: i])

    return res
```

3. Отметьте все верные команды создания объекта стека на языке `С++`

![image](https://user-images.githubusercontent.com/124737857/230661223-fd2aa375-f04e-4feb-8553-da93462c95a5.png)

![image](https://user-images.githubusercontent.com/124737857/230661376-706997f2-7f1d-4b62-bee7-56dde5f15730.png)

4. Создайте в программе на `С++` в функции `main()` стек с помощью следующей команды:

```c++
std::stack<int> st;
```

Занесите в этот стек последовательно числа, прочитанные из входного потока, с помощью следующего фрагмента программы:

```c++
int x;
while (!feof(stdin)) {
	cin >> x;
	st.push(x);
}
```

Извлеките все значения стека и выведите их на экран в одну строчку через пробел в порядке извлечения.

```c++
#include <iostream>
#include <stack>

int main(void)
{
    using namespace std;
    stack<int> st;
    
    int x;
    while (!feof(stdin)) {
        cin >> x;
        st.push(x);
    }
    
    while (!st.empty()){
        cout << st.top() << " ";
        st.pop();
    }

    return 0;
}
```

5. Объявите в программе на `С++` перед функцией `main()` функцию со следующей сигнатурой:

```c++
void get_sub_eq(const std::string& eq_str, std::vector<std::string>& res) 
{
}
```

Допишите эту функцию так, чтобы она выделяла все фрагменты строки `eq_str`, стоящие внутри круглых скобок, и сохраняла эти фрагменты в динамическом массиве `res`.

```c++
#include <iostream>
#include <vector>
#include <stack>

void get_sub_eq(const std::string& eq_str, std::vector<std::string>& res) 
{
    std::stack<int> st;
    for(int i = 0; i != eq_str.length(); ++i)
        if (eq_str[i] == '(') st.push(i);
        else if (eq_str[i] == ')'){ 
            res.push_back(eq_str.substr(st.top()+1, i-st.top()-1));
            st.pop();
        }
}

int main(void)
{
    using namespace std;

    return 0;
}
```


