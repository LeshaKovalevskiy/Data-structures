## Двусвязный список (list) в STL на С++

Чтобы воспользоваться этой коллекцией данных, вначале нужно подключить модуль list:

```c++
#include <list>
```

А, затем, в функции `main()` определить объект класса `list`, например, так:

```c++
int main()
{
         using namespace std;
 
         list<int> lst;
 
         return 0;
}
```

Все, у нас в программе имеется объект `lst`, который представляет собой двусвязный список. Обратите внимание, в угловых скобках прописан тип `int` – тот тип данных,
который предполагается хранить в элементах двусвязного списка. Вместо типа `int` можно прописать любой другой, включая собственные определения классов и структур.
То есть, мы здесь имеем универсальную реализацию списка, который может работать с любыми типами данных. Но для простоты пусть будет тип `int`.

При создании двусвязного списка командой:

```c++
list<int> lst;
```

создается пустой список (без элементов). Мы в этом можем легко убедиться, если вызовем метод `size()`, который возвращает общее число элементов:

```c++
cout << lst.size() << endl;
```

Если же нам нужно прописать в список некоторый набор начальных значений, то это можно сделать так:

```c++
list<int> lst = {1, 5, 3, 2};
```

или так:

```c++
list<int> lst {1, 5, 3, 2};
```

В обоих случаях мы получим список из четырех элементов со значениями 1, 5, 3, 2. Давайте выведем их в консоль:

```c++
for (auto it = lst.cbegin(); it != lst.cend(); it++)
         cout << *it << " ";
cout << endl;
```

Чтобы перебрать элементы связного списка используется механизм итераторов, который в `С++` нужно прописывать явно. Вначале с помощь метода `cbegin()` получаем
константный итератор, установленный в самое начало списка. Затем, делаем цикл до тех пор, пока адрес итератора не равен конечному адресу. А оператор `it++` позволяет 
сместить итератор на следующий элемент списка. В самом цикле с помощью операции разыменования указателя `*it` получаем значение текущего элемента списка и выводим его
в консоль. Фактически, с помощью итератора мы последовательно переходим от одного элемента к другому, используя ссылки `next` и `prev`, которые есть у каждого объекта
двусвязного списка.

У двусвязного списка `list` имеются методы:

`cbegin()` и `cend()` – для работы с константным итератором;
`begin()` и `end()` – для работы с обычным итератором.

Отличие между этими методами заключается в том, что через константный итератор нельзя менять значения списка (только читать), а через обычный – можно. Во всем
остальном они работают одинаково.

Далее, если нам нужно просто получить значения первого или последнего элементов, то для этого существуют методы `front()` и `back()`:

```c++
cout << lst.front() << endl;
cout << lst.back() << endl;
```

Видим значения 1 и 2.

Следующий часто используемый метод `empty()`, который возвращает булево значение `true` – если список пуст, и `false` в противном случае. Например, методы `front()` и
`back()` будут приводить к ошибке, если их вызвать для пустого списка. Поэтому правильнее было бы обращаться к ним с проверкой:

```c++
if (!lst.empty()) {
         cout << lst.front() << endl;
         cout << lst.back() << endl;
}
```

## Добавление элементов в список

Следующий набор методов, используемый для добавления элементов в двусвязный список. Методы `push_back()` и `push_front()` используются для добавления элементов в конец
и начало списка. Например:

```c++
list<int> lst;
 
lst.push_back(1);
lst.push_front(4);
lst.push_front(-4);
lst.push_back(-1);
```

Увидим значения: -4, 4, 1, -1.

Если нам требуется вставить какое-либо значение в произвольную позицию, то для этого используется метод `insert()`. Этот метод использует итератор для указания
позиции вставки. Например, если определить итератор с помощью команды:

```c++
auto pos_it = lst.cbegin();
```

то получим указатель на первую позицию, куда и будет вставлен элемент:

```c++
lst.insert(pos_it, 100);
```

Если нужно вставить во вторую позицию, то это можно сделать так:

```c++
auto pos_it = lst.cbegin();
pos_it++;
lst.insert(pos_it, 100);
```

или в более краткой записи:

```c++
auto pos_it = lst.cbegin();
lst.insert(++pos_it, 100);
```

Обратите внимание, что оператор `++` должен быть записан перед итератором `pos_it`. Если его прописать после, то сначала будет выполнен метод `insert()` и только потом
изменится итератор на единицу.

Если нужно вставить элемент в произвольную `k`-ю позицию, то сначала итератор устанавливается в эту позицию, например, с помощью цикла:

```c++
auto pos_it = lst.cbegin();
int n = 3;
for (int k = 0; k < n; ++pos_it, ++k);
lst.insert(pos_it, 100);
```

Также с помощью `insert()` можно относительно просто вставить сразу несколько одинаковых значений, например, так:

```c++
lst.insert(pos_it, 5, 3);
```

Выполняется вставка пяти троек, начиная с позиции `pos_it`.

## Удаление элементов из списка

Последняя группа методов связана с удалением элементов из списка. Если нам нужно очистить список (удалить все элементы), то это делается с помощью метода `clear()`:

```c++
lst.clear();
```

Для удаления первого или последнего элемента – методы `pop_front()` и `pop_back()`:

```c++
lst.pop_front();
lst.pop_back();
```

Наконец, удаление произвольного элемента выполняется методом `erase()`. Здесь также, как и в методе `insert()`, необходимо определить итератор на удаляемый элемент,
например, так:

```c++
auto pos_it = lst.cbegin();
lst.erase(++pos_it);
```

В результате будет удален второй элемент. Либо можно задать границы удаляемых элементов через итераторы:

```c++
auto start_it = lst.cbegin();
auto end_it = lst.cend();
lst.erase(++start_it, --end_it);
```

С другими полезными методами двухсвязного списка можно ознакомится:

https://en.cppreference.com/w/cpp/container/list

Основные методы:

| Метод | Описание|Сложность|
|-------|---------|----------------|
|size()| Возвращает число элементов в списке | O(1) |
|begin(), cbegin()| Возвращает итератор на первый элемент списка | O(1) |
|end(), cend()| Возвращает итератор на последний элемент списка | O(1) |
|front()| Получение значения первого элемента | O(1) |
|back()| Получение значения последнего элемента | O(1) |
|push_back()|Вставка нового элемента в конец списка|O(1)|
|push_front()|Вставка нового элемента в начало списка|O(1)|
|insert()| Вставка нового элемента в произвольную позицию |O(n)|
|clear()|Очистка двусвязного списка|-|
|pop_front()|Удаление первого элемента из списка|O(1)|
|pop_back()|Удаление последнего элемента из списка|O(1)|
|erase()|Удаление произвольного элемента списка|O(n)|

## Задания

1. Выберите верные варианты создания объекта двусвязного списка (класса list) на С++.

![image](https://user-images.githubusercontent.com/124737857/230450246-283cbbec-0451-4f40-a67d-d53a9e662081.png)

![image](https://user-images.githubusercontent.com/124737857/230450445-8da6c48a-f972-4d03-8296-73daea1be7d0.png)

2. Создайте в программе (в функции main) объект двусвязного списка с помощью команды:

```c++
std::list<short> lst;
```

В этот список из входного потока необходимо занести числа с помощью следующего программного кода:

```c++
short x;
while (!feof(stdin)) {
	cin >> x;
	lst.push_back(x);
}
```

Выведите на экран в одну строчку через пробел по порядку значения элементов списка `lst` через один, начиная с первого.

```c++
#include <iostream>
#include <list>

int main(void)
{
    using namespace std;
    list<short> lst;
    short x;
    while (!feof(stdin)) {
        cin >> x;
        lst.push_back(x);
    }

    int i = 0;
    for (auto it = lst.cbegin(); it != lst.cend(); it++, i++) {
        if (i % 2 == 0)
            cout << *it << " ";
    }

    return 0;
}
```

3. Создайте в программе (в функции main) объекты двусвязного списка и динамического массива с помощью команд:

```c++
std::list<unsigned int> lst;
std::vector<unsigned int> ar_d;
```

Добавьте по порядку в список lst следующие числа:

```
1 2 3 5 7 11 13 17 19 23
```

То есть, первый элемент должен содержать число 1, второй - 2 и т.д.

Перед функцией `main()` объявите функцию со следующей сигнатурой:

```c++
void copy_to_array(std::vector<unsigned int>& dest, const std::list<unsigned int>& src)
{
}
```

Допишите функцию `copy_to_array()` так, чтобы она копировала значения элементов списка `src` в динамический массив `dest`.

Вызовите функцию `copy_to_array()` в функции `main()` для копирования в динамический массив `ar_d` списка `lst`.

```c++
#include <iostream>
#include <list>
#include <vector>
using namespace std;

void copy_to_array(vector<unsigned int>& dest, const list<unsigned int>& src)
{
    for (auto it = src.cbegin(); it != src.cend(); it++)
        dest.push_back(*it);
}

int main(void)
{
    list<unsigned int> lst{ 1, 2, 3, 5, 7, 11, 13, 17, 19, 23 };
    vector<unsigned int> ar_d;
    copy_to_array(ar_d, lst);

    return 0;
}
```

4. Необходимо объявить двусвязный список, который бы хранил информацию об автомобилях. Для этого в программе объявлена следующая структура:

```c++
typedef struct {
	char model[50];		// модель
	short year;		// год выпуска
	int distance;		// пробег (в  км.)
	short power;		// мощность (в л.с.)
} AUTO;
```

А, затем, в функции `main()` создается список с помощью команды:

```c++
std::list<AUTO> autos;
```

Занесите в этот список следующую информацию так, чтобы первая запись была в первом элементе списка, вторая - во втором и т.д.:

```
порше        2005    200430    143
тойота        2011    80754    124
опель        2017    75730    147
бмв        2015    100450    230
мерседес        2004    245034    156
```

Перед функцией `main()` объявите функцию со следующей сигнатурой:

```c++
void filter_auto(const std::list<AUTO>& autos, std::list<AUTO>* results)
{
}
```

Эта функция должна в список `results` заносить (копировать) автомобили из списка `autos` с годом выпуска ниже 2014.

Вызовите в функции `main()` функцию `filter_auto()` для обработки списка `autos`. Выведите на экран в одну строчку через пробел марки машин, попавших в список 
`results` в порядке их следования в списке `autos`.

P.S. Если в программе выполнялось выделение памяти, то не забудьте в конце ее освободить.

```c++
#include <iostream>
#include <list>
using namespace std;

typedef struct {
    char model[50];		// модель
    short year;		// год выпуска
    int distance;		// пробег (в  км.)
    short power;		// мощность (в л.с.)
} AUTO;

void filter_auto(const std::list<AUTO>& autos, std::list<AUTO>* results)
{
    for (auto it = autos.cbegin(); it != autos.cend(); it++)
        if (it->year < 2014) results->push_back(*it);
 }


int main(void)
{   
    setlocale(LC_ALL, "ru");
    using namespace std;
    list<AUTO> autos;
    AUTO cars[5] = {
        {"порше", 2005, 200430, 143},
        {"тойота", 2011, 80754, 124},
        {"опель", 2017, 75730, 147},
        {"бмв", 2015, 100450, 230},
        {"мерседес", 2004, 245034, 156}
    };

    list<AUTO>* results = new list<AUTO>();

    for (int i = 0; i < 5; i++) autos.push_back(cars[i]);

    filter_auto(autos, results);

    for (auto it = results->cbegin(); it != results->cend(); it++) cout << it->model << " ";


    delete results;
    return 0;
}
```

5. Предположим, мы решили в программе хранить оценки студентов в двусвязном списке. Для этого вначале в программе объявляется следующая структура:

```c++
typedef struct {
	char fio[100];			// ФИО студента
	std::vector<char>* marks;	// динамический массив для оценок
} STUDENT;
```

А, затем, в функции `main()` следующий двусвязный список:

```c++
std::list<STUDENT> students;
```

Ваша задача продолжить эту программу (внутри функции main) и занести в этот двусвязный список следующую информацию по студентам:

```
Галий Ю.    2 3 4 5
Аврелий М.    5 3 5 2 5 5
Балакирев С.    2 4
```

В первом объекте должна храниться первая строчка информации, во втором - вторая и т.д. Не забудьте в конце программы (перед оператором return 0) выполнить
освобождение ранее выделенной памяти.

```c++
#include <iostream>
#include <list>
#include <vector>

typedef struct {
    char fio[100];			// ФИО студента
    std::vector<char>* marks;	// динамический массив для оценок
} STUDENT;

int main(void)
{
    setlocale(LC_ALL, "ru");
    using namespace std;
    list<STUDENT> students;
  
    vector<char>* marks1 = new vector<char>();
    *marks1 = { 2, 3, 4, 5 };
    vector<char>* marks2 = new vector<char>();
    *marks2 = { 5, 3, 5, 2, 5, 5 };
    vector<char>* marks3 = new vector<char>();
    *marks3 = { 2, 4 };
    
    STUDENT items[3] = {
        { "Галий Ю.", marks1 },
        { "Аврелий М.", marks2 },
        { "Балакирев С.", marks3 }
    };
    
    for (auto item: items) students.push_back(item);

    delete marks1;
    delete marks2;
    delete marks3;
    return 0;
}
```
