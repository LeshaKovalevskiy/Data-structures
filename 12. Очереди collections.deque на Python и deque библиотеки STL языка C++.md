## Очереди collections.deque на Python и deque библиотеки STL языка C++

Класс `deque`, по сути, реализует двусвязный список со всеми наборами операций: добавления/удаления граничных элементов, вставки и удаления промежуточных, а также
доступ к произвольным элементам. Поэтому коллекцию `deque` в `Python` также можно использовать, как полноценный двухсвязный список.

Подробное описание всех методов класса `deque` можно найти на странице официальной документации:

https://docs.python.org/3/library/collections.html#collections.deque

В частности, там отмечается, что операции добавления/удаления граничных значений выполняется за `O(1)` операций, а вставки/удаления промежуточных элементов за `O(n)`
операций. Доступ к произвольным элементам также требует `O(n)` операций.

Основные методы очереди `deque`:

| Метод | Описание|Объем вычислений|
|-------|---------|----------------|
|append()| Добавление элемента в конец списка | O(1) |
|appendleft()| Добавление элемента в начало списка | O(1) |
|pop()| Удаление элемента с конца списка | O(1) |
|popleft()| Удаление элемента с начала списка | O(1) |
|extend()| Добавление нескольких `m` элементов в конец списка | O(m) |
|extendleft()|Добавление нескольких `m` элементов в начало списка|O(m)|
|insert()|Вставка элемента в произвольную позицию|O(n)|
|remove()|Удаление элемента списка с указанным значением |O(n)|
|clear()|Удаление всех элементов списка|O(1)|
|copy()|Создание копии двусвязного списка|O(n)|

Чтобы воспользоваться этими методами, вначале нужно импортировать класс deque, например, так:

```python
from collections import deque
```

и создать объект двухсторонней очереди. Общий синтаксис следующий:

```python
collections.deque([iterable[, maxlen]])
```

Здесь `iterable` – любой итерируемый объект для начальной инициализации очереди `deque` определенными значениями; `maxlen` – максимальная длина очереди
(максимальное число элементов). Если значение `maxlen` не указывается или принимает значение `None`, то очередь не ограничена по числу элементов.

В самом простом варианте пустая очередь создается командой:

```python
dq = deque()
```

Или же можно сразу указать набор требуемых начальных значений:

```python
dq = deque([1, 2, 3, 4, 5])
```

а также дополнительно указать максимальное число элементов:

```python
dq = deque([1, 2, 3, 4, 5], maxlen=5)
```

тогда коллекция `dq` будет содержать максимум 5 элементов.

### Примеры использования методов класса deque

Выведем объект `dq` на экран и убедимся, что он действительно содержит указанные начальные значения:

```python
print(dq)
```

А что будет, если в конец очереди (справа) добавить еще один элемент:

```python
dq.append(6)
```

Теперь очередь содержит значения:

```python
deque([2, 3, 4, 5, 6], maxlen=5)
```

То есть, при указании максимального числа элементов и добавлении граничного значения, другое крайнее значение удаляется.

Если выполнить добавление справа:

```python
dq.appendleft(6)
```

и мы видим результат:

```python
deque([6, 1, 2, 3, 4], maxlen=5)
```

Если уберать параметр `maxlen`:

```python
dq = deque([1, 2, 3, 4, 5])
```

Тогда при добавлении новых значений в начало или в конец очереди прежние данные теряться не будут:

```python
dq.append(6)
dq.appendleft(0)
```

Если же нам нужно удалить граничный элемент справа или слева в двусвязном списке, то следует воспользоваться методами:

```python
right = dq.pop()
left = dq.popleft()
print(left, right)
print(dq)
```

Увидим результат два значения 0 и 6, а также оставшиеся элементы в очереди:

```
deque([1, 2, 3, 4, 5])
```

Методы `pop()` и `popleft()` генерируют ошибку `IndexError`, если элемент отсутствует, то есть, список пустой. Например:

```python
dq = deque()
right = dq.pop()
left = dq.popleft()
```

приведет к ошибке. Поэтому правильнее будет эти операторы поместить в блок `try/except`:

```python
dq = deque()
try:
    right = dq.pop()
    left = dq.popleft()
    print(left, right)
    print(dq)
except IndexError as e:
    print(e)
```    
    
`extend()` и `extendleft()` добавляют сразу несколько элементов в конец или начало очереди. Работают они подобно методам `append()` и `appendleft()`, только в
качестве аргументов указывается итерируемый объект:

```python
dq = deque([1, 2, 3, 4, 5])
dq.extend((6, 7, 8))
dq.extendleft([-3, -2, -1])
print(dq)  # deque([-1, -2, -3, 1, 2, 3, 4, 5, 6, 7, 8])
```
`insert()` позволяет вставлять новый элемент в произвольную позицию, например, так:

```python
dq.insert(1, 100)
```

Получим результат:

```
deque([1, 100, 2, 3, 4, 5])
```

То есть, первым аргументом указывается индекс вставляемого элемента, а вторым – его значение.

Также можно указывать и отрицательные индексы:

```python
dq.insert(-1, 100)
```

получим:

```
deque([1, 2, 3, 4, 100, 5])
```

И несуществующие:

```python
dq.insert(77, 100)
dq.insert(-77, -100)
```

результат:

```
deque([-100, 1, 2, 3, 4, 5, 100])
```

Метод `remove()` позволяет удалять первый найденный по значению элемент в очереди, например:

```python
dq = deque([1, 2, 3, 4, 3, 5])
dq.remove(3)
```

Получим результат:

```
deque([1, 2, 4, 3, 5])
```

Если значение не находится:

```python
dq.remove(33)
```

то генерируется исключение `ValueError`.

Следующий метод `clear()` удаляет все элементы из очереди, то есть, очищает ее:

```python
dq = deque([1, 2, 3, 4, 3, 5])
dq.clear()
```

получим пустую коллекцию:

```
deque([])
```

Метод `copy()` создает копию очереди:

```python
dq = deque([1, 2, 3, 4, 3, 5])
dq2 = dq.copy()
dq2.append(100)
print(dq)
print(dq2)
```

Увидим результат:

```
deque([1, 2, 3, 4, 3, 5])
deque([1, 2, 3, 4, 3, 5, 100])
```

### Реализация очередей типа FIFO и LIFO

Вот основные методы двухсторонней очереди `deque` языка Python. Используя их, легко можно построить очереди по принципу `FIFO` и `LIFO`. Например, реализацию `FIFO`
можно выполнить следующим образом:

```python
dq.appendleft(10) # добавление в начало очереди
value = dq.pop()  # удаление с конца очереди
```

Или, наоборот:

```python
dq.append(10)  # добавление в конец очереди
value = dq.popleft() # удаление с начала очереди
```

Очередь типа `LIFO` можно сделать с помощью методов:

```python
dq.append(11)  # добавление в конец
value = dq.pop()  # удаление с конца
```

Или, наоборот:

```python
dq.appendleft(11) # добавление в начало
value = dq.popleft() # удаление с начала
```

## Задания

1. С помощью класса `deque` создайте буфер с именем `buff` для приема информации (целых чисел) с максимальным размером в 10 элементов. Буфер должен быть реализован
по принципу очереди `FIFO`, причем добавление новых данных должно осуществляться в начало очереди (слева), а извлечение - справа (с конца очереди).

Поместите в этот буфер данные `data`, прочитанные из входного потока:

```python
data = list(map(int, input().split()))
```

Извлеките из буфера три элемента (три числа) и выведите их в консоль в порядке считывания из буфера в одну строчку через пробел.

```python
from collections import deque

data = list(map(int, input().split()))  # этот список в программе не менять

buff = deque(maxlen=10)
buff.extendleft(data)
print(*[buff.pop() for _ in "..."])
```

2. Вам в браузере нужно реализовать кнопку `back` (`<`, назад). Для этого решено воспользоваться очередью типа `LIFO`, которая бы хранила историю посещения страниц
пользователем (история `URL`-адресов).

Создайте вначале в программе объект с именем `back_url` класса `deque`, который бы содержал максимум 20 `URL`-адресов. Данные предполагается добавлять и извлекать
с конца очереди (справа).

Добавьте в очередь `back_url` по порядку `URL`-адреса, прочитанные из входного потока:

```python
lst_in = list(map(str.strip, sys.stdin.readlines()))
```

Извлеките один (первый) элемент из очереди и отобразите его в консоли.

```python
import sys
from collections import deque

lst_in = list(map(str.strip, sys.stdin.readlines()))  # этот список в программе не менять

back_url = deque(maxlen=20)
back_url.extend(lst_in)
print(back_url.pop())
```

## Очередь deque библиотеки STL языка C++

Этот контейтер реализует функционал двухсторонней очереди, то есть, возможность добавления и удаления элементов и в конец и в начало.

Однако в `С++` очередь имеет особую реализацию в виде гибрида двусвязного списка и динамических массивов:

![image](https://user-images.githubusercontent.com/124737857/230421398-4d417013-9c8f-45ca-b7a4-bcb2c3867da2.png)

В примере, первые три значения 0, 1, 2 хранятся в первом массиве(первого элемента двусвязного списка), следующие три значения – во втором массиве (и втором элементе
списка) и так далее.

В пределах одного массива мы достаточно быстро можем обратиться к произвольному элементу – за время `O(1)`. Значит, если нам нужно получить значение `k`-го элемента,
то вначале определяем элемент списка, в котором он находится:

```
j = k // size_array
```

(здесь оператор `//` - целочисленное деление; `size_array` – максимальное число элементов в массивах, массивы полагаем равной длины во всех объектах двусвязного
списка).

Затем в массиве `j`-го объекта переходим к нужному элементу массива:

```
i = k % size_array
```

(здесь оператор `%` - вычисление целого остатка от деления).

Все, в итоге, нам нужно перебрать только первые `j` значений двусвязного списка, вместо `k`, если бы использовался обычный список. Это заметно ускоряет доступ к
отдельным элементам очереди. И в этом главная причина использования такой структуры данных в объекте `deque` языка `С++`.

Но есть и недостатки в сравнении с обычными двусвязными списками. Операции добавления/удаления граничных элементов работают несколько дольше, т.к. приходится смещать
элементы динамических массивов. 

Также несколько больше операций может занимать и вставка/удаление промежуточных значений.

## Использование класса deque в С++

Для использования в программе класса `deque` вначале нужно подключить заголовок с таким же названием:

```c++
#include <deque>
```

После этого в пространстве имен `std` появится класс `deque`:

```c++
int main()
{
         deque<int> dq;
 
         return 0;
}
```

Итак, команда

```c++
deque<int> dq;
```

создает пустую очередь (без элементов) с типом данных в элементах `int`.

Если нужно инициализировать очередь некоторыми начальными значениями, то это можно сделать так:

```c++
deque<int> dq = { 1, 2, 3 };
```

или так:

```c++
deque<int> dq { 1, 2, 3 };
```

Отобразим элементы списка в консоли:

```c++
for (int i = 0; i < dq.size(); i++){
		cout << dq[i] << " ";
}
``` 

Здесь метод `size()` возвращает общее число элементов в списке. А обращение к значению отдельного элемента осуществляется по индексу, используя оператор квадратные
скобки. Аналогичный результат можно получить с помощью метода `at()`:

```c++
for (int i = 0; i < dq.size(); i++){
		cout << dq.at(i) << " ";
}
```

Однако, доступ к отдельным элементам объекта `deque` требует `O(n)` операций, где `n` – число объектов в двусвязном списке. Поэтому, лучше выводить
последовательные значения, используя механизм итераторов, следующим образом:

```c++
for (auto it = dq.cbegin(); it != dq.cend(); it++)
		cout << *it << " ";
```

Такая конструкция будет работать быстрее и выигрыш становится тем больше, чем больше элементов в списке.

Для получения значения первого или последнего элементов используются методы `front()` и `back()`:

```c++
cout << dq.front() << endl;
cout << dq.back() << endl;
```

Для добавления новых элементов в начало или конец списка – методы `push_front()` и `push_back()`:

```c++
dq.push_front(0);
dq.push_back(10);
```

Удаление первого или последнего элемента осуществляется с помощью методов `pop_front()` и `pop_back()`:

```c++
dq.pop_front();
dq.pop_back();
```

Обратите внимание, эти методы не возвращают значений удаляемых элементов. За это отвечают ранее рассмотренные методы `front()` и `back()`.

Также объект `deque` поддерживает операции вставки и удаления промежуточных элементов. Они реализуются методами `insert()` и `erase()` и работают по тому же принципу,
что и в двусвязных списках:

```c++
auto pos_it = dq.cbegin();
int n = 1;
for (int k = 0; k < n; ++pos_it, ++k);
dq.insert(pos_it, 100);
```

И метод `erase()`:

```c++
auto pos_it = dq.cbegin();
dq.erase(++pos_it);
```

Метод `clear()` для очистки (удаления) всех элементов очереди:

```c++
dq.clear();
```

Подробно ознакомиться с операциями можно на ресурсе:

https://en.cppreference.com/w/cpp/container/deque

Наиболее используемые методы класса deque:

| Метод | Описание|Сложность|
|-------|---------|----------------|
|size()| Возвращает число элементов в очереди | O(1) |
|at() или []| Доступ к произвольному элементу очереди | O(n) |
|begin(), cbegin()| Возвращает итератор на первый элемент очереди | O(1) |
|end(), cend()| Возвращает итератор на последний элемент очереди | O(1) |
|front()| Получение значения первого элемента | O(1) |
|back()|Получение значения последнего элемента|O(1)|
|push_back()| Вставка нового элемента в конец очереди|O(1)|
|push_front()| Вставка нового элемента в начало очереди |O(1)|
|insert()|Вставка нового элемента в произвольную позицию|O(n)|
|clear()|Очистка очереди| - |
|pop_front()|Удаление первого элемента из очереди| O(1) |
|pop_back()|Удаление последнего элемента из очереди| O(1) |
|erase()|Удаление произвольного элемента очереди| O(n) |

## Задания:

1. Выберите все верные утверждения для класса deque библиотеки `STL` языка `С++`

![image](https://user-images.githubusercontent.com/124737857/230627051-9afffe23-566e-4258-b362-b6a4ee080793.png)

![image](https://user-images.githubusercontent.com/124737857/230627344-0b322383-77db-4bd0-8dbf-0809c74fd084.png)

2. Отметьте все верные варианты команд создания объекта класса `deque` библиотеки `STL`.

![image](https://user-images.githubusercontent.com/124737857/230627896-0f4a8647-5b0a-480b-8da5-b95b8d087208.png)

![image](https://user-images.githubusercontent.com/124737857/230628058-61b17294-6c72-4a3f-aaa0-f7b8062d0258.png)

3. Создайте в функции `main()` объект класса deque с помощью следующей команды:

```c++
std::deque<int> dq;
```

Добавьте в конец этой очереди (справа) последовательно значения, прочитанные из входного потока с помощью следующего фрагмента программы:

```c++
int x;
while (!feof(stdin)) {
	cin >> x;
	dq.push_back(x);
}
```

Извлеките с начала этой очереди (слева) два элемента и выведите их на экран в одну строчку через пробел (в порядке их извлечения).

```c++
#include <iostream>
#include <deque>

int main(void)
{
    using namespace std;
    deque<int> dq;
    
    int x;
    while (!feof(stdin)) {
        cin >> x;
        dq.push_back(x);
    }
    
    cout << dq.front() << " ";
    dq.pop_front();
    cout << dq.front();
    dq.pop_front();

    return 0;
}
```

4. Объявите перед функцией `main()` следующую структуру для описания товара:

```c++
typedef struct {
	char name[100];		// наименование товара
	double price;		// цена товара (в руб.)
	unsigned int weight;	// вес товара (в граммах)
} THING;
```

В функции `main()` создайте объект очереди командой:

```c++
std::deque<THING> goods;
```

Занесите в начало этой очереди (слева) последовательно следующие товары:

```
конфеты 320.0 400
книга 1024.78 1000
кофе 512.64 300
сумка 2048.0 400
кофта 1048.24 1204
```

Выведите на экран в одну строчку через пробел названия товаров, вес которых меньше 700 грамм в порядке их следования в очереди `goods`, то есть, слева-направо.
(При выводе очередь `goods` меняться не должна).

```c++
#include <iostream>
#include <deque>

typedef struct {
    char name[100];		// наименование товара
    double price;		// цена товара (в руб.)
    unsigned int weight;	// вес товара (в граммах)
} THING;

int main(void)
{   
    setlocale(LC_ALL, "ru");
    using namespace std;
    deque<THING> goods;

    THING items[5] = {
        {"конфеты", 320.0, 400},
        {"книга", 1024.78, 1000},
        {"кофе", 512.64, 300},
        {"сумка", 2048.0, 400},
        {"кофта", 1048.24, 1204}
    };

    for (auto item : items) goods.push_front(item);

    for (auto it = goods.cbegin(); it != goods.cend(); it++)
        if (it->weight < 700) {
            cout << it->name << " ";
        }

    return 0;
}
```

5. Объявите в функции `main()` объект очереди с помощью следующей команды:

```c++
std::deque<int> dq = {1, 0, 2, 3, 4, -5, 7, -11, 10, 8, 45, 3, 1024};
```

а также динамический массив:

```c++
std::vector<int> v;
```

Перед функцией `main()` объявите функцию со следующей сигнатурой:

```c++
template <typename T>
void retrive_to_vector(const std::deque<T>& d, std::vector<T>& v, unsigned int max_size)
{
}
```

Функция `retrive_to_vector()` должна принимать ссылки на очередь (`deque`) и динамический массив (`vector`) и выполнять чтение `max_size` элементов с конца очереди
(справа) с их занесением в массив `v`. Прочитанные данные должны добавляться в конец массива `v`. Очередь, при этом, меняться не должна. Если значение `max_size`
больше числа элементов в очереди, то в массив `v` копируются все значения элементов очереди.

В функции `main()` вызовите функцию `retrive_to_vector()` со значением `max_size = 5`.

```c++
#include <iostream>
#include <deque>
#include <vector>

template <typename T>
void retrive_to_vector(const std::deque<T>& d, std::vector<T>& v, unsigned int max_size)
{
    for (auto it = d.cend() - 1; it != d.cbegin() && max_size > 0; it--, max_size--)
        v.push_back(*it);
    if (max_size) v.push_back(*d.cbegin());
}


int main(void)
{
    using namespace std;
    deque<int> dq = { 1, 0, 2, 3, 4, -5, 7, -11, 10, 8, 45, 3, 1024 };
    vector<int> v;
    retrive_to_vector(dq, v, 5);

    return 0;
}
```
