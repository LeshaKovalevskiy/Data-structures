## Множества (set). Операции над множествами

Бинарное дерево можно использовать, как самостоятельную структуру данных. Но также оно применяется в качестве основы других известных структур, например,
упорядоченных множеств.

Само по себе множество (`set`) – это коллекция данных, состоящая из уникальных значений. То есть, дубли в нем отсутствуют. Множества реализованы практически во всех
высокоуровневых языках, в том числе `Python` и `С++`. Но множества в `Python` являются неупорядоченными коллекциями и сделаны на базе хэш-таблиц. В языке `С++`
имеются упорядоченные множества, которые определены в стандартной библиотеки шаблонов `STL` через класс `set`. Причем, в их основе лежат бинарные красно-черные деревья.

В вершинах дерева, как правило, хранятся уникальные значения. А это именно то, что требуется для множеств. Во-вторых, поиск некоторого значения в бинарном дереве
выполняется за логарифмическое время (`O(log n)` операций). Благодаря этому, относительно быстро можно реализовать оператор проверки принадлежности какого-либо
значения множеству:

```python
value in s
```

В-третьих, при обходе дерева в глубину по алгоритму `LNR` получаем упорядоченную по возрастанию последовательность данных.

Благодаря простому получению упорядоченных значений элементов множества, мы можем относительно легко реализовать алгоритмы сравнения двух множеств между собой. При
сравнении на равенство:

```python
setA == setB
```

достаточно проверить равенство числа элементов в множествах, выстроить значения по возрастанию и попарно их сравнить между собой. Если окажется, что множества
содержат одинаковое число элементов и все соответствующие упорядоченные значения равны между собой, то два множества считаются равными.

Скорость работы этой операции можно оценить как `O(n)`, где `n` – число элементов в множествах. К примеру, если бы данные нельзя было упорядочить, как это происходит
в динамических массивах, то объем вычислений при сравнении составил бы `O(n^2)`.

По аналогии можно получить быстрые алгоритмы при определении вхождения одного множества в другое, то есть, операции меньше и больше(множество `setB` входит в `setA`,
если множество `setA` содержит все те же самые элементы, что и множество `setB`:

![image](https://user-images.githubusercontent.com/124737857/230742879-a4891d64-64b4-462d-9c67-22d719e86a05.png)

Например, возьмем множества

```python
setA = {7, 6, 5, 4, 3}
setB = {3, 4, 5}
```

тогда операция

```python
setB < setA
```

вернет `True`.

Давайте теперь посмотрим, как реализуется алгоритм сравнения множеств на меньше или больше.

Например, если даны множества:

```python
setA = {5, 7, 6, 2, 4, 3}
setB = {3, 6, 4}
```

то после упорядочения по возрастанию получим последовательности:

```
setA: 2, 3, 4, 5, 6, 7
setB: 3, 4, 6
```

Затем, при сравнении `setB < setA`, первым делом проверяем, чтобы число элементов в множестве `setB` было меньше, чем в `setA`. Если это не так, то множество `setB`
заведомо не может входить в множество `setA`. После этого сравниваем граничные значения множеств: наименьшее и наибольшее значения множества `setB` не должны выходить
за диапазон граничных значений множества `setA`. Если все выполняется, то далее, последовательно проходим по элементам большего множества `setA` и сравниваем с первым
значением множества `setB`. Как только значения элементов совпали, сравниваем последующие величины множества `setA` со вторым значением множества `setB`. Если при
полном проходе по `setA` находим все совпадения со значениями множества `setB`, то делаем вывод, что множество `setB` входит в множество `setA` и операция сравнения
`setB < setA` возвращает `True`. Если не было найдено хотя бы одно значение в множестве `setB`, то возвращается `False`. Причем проверку можно прерывать, если текущее
проверяемое значение в `setB` оказывается меньше текущего значения из `setA`.

Вычислительная сложность этой операции с точки зрения О большого составляет `O(n)`, где `n` – число элементов в большем множестве.

## Операции над множествами

 - при пересечении двух множеств формирует третье с элементами, которые принадлежат и первому и второму множествам;
 - при объединении двух множеств формируется третье с элементами, принадлежащими обоим множествам;
 - при вычитании двух множеств формируется третье с элементами первого множества за вычетом элементов второго множества;
 - при симметричной разности двух множеств формируется третье с элементами обоих множеств, но не принадлежащим обоим множествам одновременно.

### Алгоритм пересечения двух множеств

Пусть имеются множества:

```python
setA = {3, 5, 2, 1, 6}
setB = {7, 0, 3, 4, 5}
```

После упорядочения их значений, получаем последовательности:

![image](https://user-images.githubusercontent.com/124737857/230743090-3b13e6de-cf11-486a-8222-e88420a39021.png)

Элементы списка множества `setA` будем перебирать с помощью индекса `i`, а элементы множества `setB` – с помощью индекса `j`. Наша задача выделить общие значения
обоих множеств. Поэтому вначале проверяем на равенство элементы с индексами `i` и `j`. Если они не равны, то увеличиваем на единицу индекс, который соответствует
меньшему значению элемента. В данном примере – это индекс `j`, т.к. он ведет на элемент со значением 0. Далее, сравниваем значения 1 и 3. Так как 1 < 3, то увеличиваем
индекс `i` на единицу. Получаем следующую пару 2 и 3 и, так как 2 < 3, то снова увеличиваем `i` на единицу. Теперь оба значения в последовательностях равны 3
– совпадают. Поэтому заносим это значение в результирующее множество `setA & setB`. Далее можно увеличивать любой индекс (или оба вместе, т.к. в множествах значения
не повторяются). Продолжая получаем:

```
setA & setB = {3, 5}
```

В итоге получаем линейный объем вычислений для этой и всех последующих операций над множествами.

### Алгоритм объединения двух множеств

По аналогии работает алгоритм объединения двух множеств. Только теперь в результирующее множество добавляются все элементы из обоих множеств, но ровно один раз, чтобы
не было дублирования.

Пусть даны те же самые множества с такими же упорядоченными значениями:

![image](https://user-images.githubusercontent.com/124737857/230743159-a2bd5d27-1932-4a4c-8019-c81bf1cfc74e.png)

Вначале сравниваем пары элементов по индексам `i` и `j` на равенство. Если они не равны, то в результирующее множество добавляется наименьшее значение. Затем,
увеличиваем индекс `j` на единицу, т.к. он соответствует элементу с меньшим значением 0. Получаем пары 1 и 3. Добавляем в третье множество наименьшее значение 1 и
увеличиваем индекс `i` на единицу. Имеем пары 2 и 3. То же самое, добавляем 2 в третье множество и снова увеличиваем `i` на единицу. Теперь у нас два одинаковых
значения 3 и 3. Добавляем 3 в результирующее (третье) множество и увеличиваем оба индекса на единицу. Повторяем эту операцию пока не достигнем конца обоих множеств.
В итоге, у нас получится следующий результат их объединения:

```python
setA | setB = {0, 1, 2, 3, 4, 5, 6, 7}
```

### Алгоритм вычитания двух множеств

Снова воспользуемся теми же самыми множествами с набором упорядоченных значений:

![image](https://user-images.githubusercontent.com/124737857/230743198-fecee23f-28ae-4a1b-8d3e-35b8a05382c4.png)

Тогда для реализации алгоритма вычитания:

```python
setA - setB
```

достаточно сформировать третье множество `setC`, в котором будут находиться значения из множества `setA`, не принадлежащие множеству `setB`.

Вначале мы имеем пары значений 1 и 0 в множествах `setA` и `setB`. Так как значения разные и 0 меньше 1, то увеличиваем индекс `j` на единицу. Получаем следующую пару
1 и 3. Здесь 1 меньше 3, значит, значения 1 точно нет в множестве `setB` и мы 1 добавляем в результирующее множество `setC`. Увеличиваем индекс `i` на единицу. Здесь
2 меньше 3, поэтому 2 также помещаем в множество `setC` и увеличиваем индекс `i` на единицу. Получаем равные значения 3 и 3, поэтому смещаем оба индекса `i`, `j` на
следующий элемент. Далее аналогично.

В итоге получаем результат вычитания:

```python
setC = {1, 2, 6}
```

### Алгоритм симметричной разности двух множеств

Фактически, симметричная разность двух множеств – это их объединение с отбрасыванием общих значений. Поэтому алгоритм очень похож на алгоритм объединения множеств.

Также предположим, что у нас два множества со следующими наборами упорядоченных значений:

![image](https://user-images.githubusercontent.com/124737857/230743262-7dff7127-a2d8-418f-8cb4-33bb2816afe4.png)

Вначале сравниваем пары элементов по индексам `i` и `j` на равенство. Если они не равны, то в результирующее множество добавляется наименьшее значение. Затем,
увеличиваем индекс `j` на единицу, т.к. он соответствует элементу с меньшим значением 0. Получаем пары 1 и 3. Добавляем в третье множество наименьшее значение 1 и
увеличиваем индекс `i` на единицу. Имеем пары 2 и 3. То же самое, добавляем 2 в третье множество и снова увеличиваем `i` на единицу. Теперь у нас два одинаковых
значения 3 и 3, поэтому пропускаем это значение и увеличиваем оба индекса на единицу. Повторяем эту операцию пока не достигнем конца обоих множеств. В итоге, у нас
получится следующий результат их симметричной разности:

```python
setA ^ setB = {0, 1, 2, 4, 6, 7}
```

## Задания

1. Выберите все верные утверждения для множеств.

![image](https://user-images.githubusercontent.com/124737857/230744238-53f9c6fa-703e-4993-830a-d05f72d9e148.png)

![image](https://user-images.githubusercontent.com/124737857/230744260-78b97fdb-f07b-4e54-a80a-08f19c9da053.png)

2. Пусть даны два множества:

```python
setA = {2, 4, 7, 3, 6}
setB = {7, 1, 3, 6, 5}
```

Запишите подряд (без пробелов) в порядке возрастания числа, которые будут результатом операции `setA & setB`.

![image](https://user-images.githubusercontent.com/124737857/230744494-439897f1-b3e0-4f31-982a-d24037f77038.png)

3. Пусть даны два множества:

```python
setA = {4, 7, 5, 6, 3, 1}
setB = {7, 1, 3, 6, 5}
```

Запишите подряд (без пробелов) в порядке возрастания числа, которые будут результатом операции `setA | setB`.

![image](https://user-images.githubusercontent.com/124737857/230744524-296464a3-44fe-4c57-89b1-37f3d87d28ee.png)

4. Пусть даны два множества:

```python
setA = {2, 8, 9, 3, 1}
setB = {7, 1, 3, 6, 5}
```

Запишите подряд (без пробелов) в порядке возрастания числа, которые будут результатом операции `setA - setB`.

![image](https://user-images.githubusercontent.com/124737857/230744550-c803f5e5-ecab-4a6e-90bb-83d4b2f1aa80.png)

5. Пусть даны два множества:

```python
setA = {2, 8, 7, 3, 1}
setB = {7, 1, 3, 6, 5}
```

Запишите подряд (без пробелов) в порядке возрастания числа, которые будут результатом операции `setA ^ setB`.

![image](https://user-images.githubusercontent.com/124737857/230744591-ae57348c-8494-46eb-96fe-0f47281a2df4.png)

## Множества set и multiset в C++

В `C++` есть два класса `set` и `multiset` стандартной библиотеки шаблонов `STL`, которые представляют собой упорядоченные множества. Чтобы воспользоваться этими
классами, вначале нам нужно подключить заголовок `set` с помощью директивы `#include` следующим образом:

```c++
#include <set>
```

После этого в функции `main()` можно определить объект-множество, например, так:

```c++
int main()
{
         setlocale(LC_ALL, "ru");
         using namespace std;
 
         set<int> s;
 
         return 0;
}
```

Здесь в угловых скобках после имени класса `set`, указывается тип данных, который хранят элементы множества.

Основные методы множеств:

| Метод | Описание | Сложность |
| ----- | -------- | --------- |
| begin(), cbegin() | Возвращает итератор на первый элемент множества | O(1) |
| end(), cend() | Возвращает итератор на последний элемент множества | O(1) |
| size() | Возвращает число элементов в множестве | O(1) |
| insert() | Вставка нового элемента в произвольную позицию | O(log n) |
| erase() | Удаление произвольного элемента множества | O(log n) |
| find() | Поиск элемента по значению | O(log n) |
| clear() | Очистка множества | - |
| empty() | Возвращает true, если множество пустое и false в противном случае | O(1) |

При вызове `insert()` формируется бинарное дерево с соответствующими значениями. Например:

```c++
s.insert(10);
s.insert(5);
s.insert(7);
s.insert(16);
s.insert(13);
```

Все эти значения будут храниться в узлах следующего бинарного дерева:

![image](https://user-images.githubusercontent.com/124737857/230762264-3a37c593-75c2-4dce-9f4c-ea0efc44b922.png)

Для перебора можно воспользоваться циклом for:

```c++
for (auto& item : s)
{
    cout << item << endl;
}
```

Видим на экране упорядоченные значения по возрастанию:

```
5, 7, 10, 13, 16
```

Так как, множества `set` используют обход по алгоритму `LNR`(сначала левая ветвь, затем, вершина, потом правая ветвь).

При попытке добавить существующее значение:

```c++
s.insert(16);
```

ничего не изменится, это значение будет просто проигнорировано.

Вообще, метод `insert()` возвращает пару (итератор на элемент, булево значение):

```c++
auto it = s.insert(2);
```

Если добавление не было выполнено (например, при добавлении уже существующего значения), то второй элемент принимает значение `false`, а первый – итератор на
существующий элемент. Если же добавление произошло успешно, то первое значение – итератор на добавленный элемент, а второй элемент принимает значение `true`.

Помимо добавления новых элементов командой `insert()`, можно сразу инициализировать множество некоторыми начальными значениями, например, так:

```c++
set<int> s = {10, 5, 7, 16, 13};
```

Далее, если нам нужно найти какое-либо значение в множестве, то для этого используется метод `find()`:

```c++
auto it = s.find(5);
```

Данный метод возвращает итератор на найденный элемент, либо значение `s.end()`, если элемент не был найден. То есть, мы можем использовать такую проверку:

```c++
if (it != s.end())
    cout << *it << endl;
else
    cout << "число не найдено" << endl;
```         
         
Для удаления какого-либо значения из множества используется метод `erase()`:

```c++
s.erase(13);
```

При удалении несуществующего элемента:

```c++
s.erase(133);
```

ничего не происходит, множество остается без изменений.

Вообще, метод `erase()` возвращает 0, если удаление не было выполнено (например, при удалении несуществующего значения) и 1, если удаление выполнено успешно.

## Контейнер multiset

В библиотеке `STL` есть еще одна похожая коллекция `multiset`, которая тоже представляет множество, но с возможностью хранить повторяющиеся значения. Для ее
использования в программе нужно подключить тот же заголовок `set`:

```c++
#include <set>
```

И, затем, в программе создать объект этого класса, подобно классу set:

```c++
multiset<int> ms;
 
ms.insert(1);
ms.insert(1);
ms.insert(5);
ms.insert(7);
ms.insert(16);
ms.insert(13);
 
for (auto& item : ms)
{
         cout << item << endl;
}
```

Так как в множестве могут присутствовать повторяющиеся значения, то дополнительно имеются методы `lower_bound()` и `upper_bound()`:

```c++
multiset<int> ms = { 0, 2, 2, 2, 2, 13, 16, 7, 5 };
auto it1 = ms.lower_bound(2);
auto it2 = ms.upper_bound(2);
 
cout << *it1 << endl;
cout << *it2 << endl;
```

которые возвращают итератор на первое найденное значение 2 и на следующее значение после последней 2. Если значение не найдено, то итератор равен `ms.end()`.

Также есть метод `equal_range()`, который возвращает диапазон итераторов для указанного значения. Например:

```c++
auto r = ms.equal_range(2);
for (auto it = r.first; it != r.second; ++it)
         cout << *it << " " << endl;
```

Будут выведены все двойки.

## Операции над множествами в C++

Для использования основных операций над множествами подключим еще один заголовок:

```c++
#include <algorithm>
```

В нем содержатся различные функции для выполнения операций над коллекциями, в том числе, и над множествами.

Далее, сформируем два множества:

```c++
set<int> setA = { 1, 3, 4, 5, 7 };
set<int> setB = { 0, 2, 3, 5, 4 };
```

и третье пустое для хранения результата:

```c++
set<int> setC;
```

Теперь мы можем использовать четыре функции:

 - `set_intersection()` – пересечение множеств;
 - `set_union()` – объединение множеств;
 - `set_difference()` – вычитание множеств;
 - `set_symmetric_difference()` – симметричная разность множеств.

Предположим, мы хотим вычислить пересечение двух множеств `setA&setB`. При вызове функции `set_intersection()` необходимо передать итераторы на диапазон элементов
множеств `setA` и `setB`, которые будут участвовать в вычислении операции пересечения. В самом простом и распространенном варианте мы указываем начало множеств и до
конца:

```c++
set_intersection(setA.begin(), setA.end(), 
                   setB.begin(), setB.end(), 
                   inserter(setC, setC.begin()));
```

В последний аргумент передается итератор для вставки значений в множество `setC`. Этот итератор формируется с помощью функции `inserter()` стандартной библиотеки.

После вывода значений множества `setC` в консоль:

```c++
for (auto& item : setC)
         cout << item << " ";
 
cout << endl;
```

увидим значения:

```
3, 4, 5
```

По аналогии выполняются три остальные функции:

```c++
set_union(setA.begin(), setA.end(),
         setB.begin(), setB.end(),
         inserter(setC, setC.begin()));
 
set_difference(setA.begin(), setA.end(),
         setB.begin(), setB.end(),
         inserter(setC, setC.begin()));
 
set_symmetric_difference(setA.begin(), setA.end(),
         setB.begin(), setB.end(),
         inserter(setC, setC.begin()));
```

## Задания

1. Отметьте все команды, которые создают объект множества (класса `set`).

![image](https://user-images.githubusercontent.com/124737857/230765999-9a88bfda-9595-4560-824d-fee31843cb80.png)

![image](https://user-images.githubusercontent.com/124737857/230766175-00ac72f0-7139-474d-b5c4-705a83ac1f97.png)

2. Объявите в функции `main()` пустое множество с именем `s` с помощью команды:

```c++
std::set<short> s;
```

Прочитайте из входного потока значения и занесите их в множество s следующим образом:

```c++
short x;
while (!feof(stdin)) {
	cin >> x;
	s.insert(x);
}
```

Выполните проверку наличия значения 10 в множестве `s`. Если оно там есть, то выведите в консоль строку `"true"`, а иначе строку `"false"`.

```c++
#include <iostream>
#include <set>

int main(void)
{
    using namespace std;
    set<short> s;
    
    short x;
    while (!feof(stdin)) {
        cin >> x;
        s.insert(x);
    }
    
    auto it = s.find(10);
    
    if (it != s.end())
        cout << "true";
    else
        cout << "false";

    return 0;
}
```

3. В программе (внутри функции `main()`) формируются два множества следующим образом:

```c++
std::set<int> a, b;

int x, y;
while (!feof(stdin)) {
	cin >> x;
	a.insert(x);

	cin >> y;
	b.insert(y);
}
```

Выполните операцию вычитания из множества `a` множества `b`. Результат сохраните в множестве `c`. Выведите на экран значения множества c в одну строчку через
пробел.

```c++
#include <iostream>
#include <set>
#include <algorithm>

int main(void)
{
    using namespace std;
    set<int> a, b, c;

    int x, y;
    while (!feof(stdin)) {
        cin >> x;
        a.insert(x);

        cin >> y;
        b.insert(y);
    }
    
    set_difference(a.begin(), a.end(),
         b.begin(), b.end(),
         inserter(c, c.begin()));
    
    for (auto& item: c) cout << item << " ";

    return 0;
}
```

