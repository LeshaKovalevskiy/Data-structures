## Односвязный список. Структура и основные операции

Недостатки динамических массивов:

 - расширение массива ресурсоемкая операция(O(n))
 - все данные должны храниться в непрерывной области памяти, а это дополнительная проблема для массивов очень больших размеров.

Решает эти проблемы - связный список.

**Односвязный список** - структура данных, в которой элементы ссылаются друг на друга по порядку в одном направлении, начиная от первого и до последнего.

![image](https://user-images.githubusercontent.com/124737857/227741081-93bc21ec-4ebd-4e64-b2fe-5e320030b837.png)

### Добавление элементов в конец и начало односвязного списка

Предположим, что в списке всего два объекта. На первый элемент (объект) всегда ссылается переменная head, а на последний – переменная tail:

![image](https://user-images.githubusercontent.com/124737857/227741103-497528b8-9e58-47af-9e7f-eacb26f066ff.png)

Мы хотим добавить в конец еще один элемент. Для этого, сначала нужно создать сам объект нового элемента списка (пусть на него ссылается временная переменная node). 
Затем, по ссылке tail выбираем последний элемент списка (который скоро станет предпоследним) и ссылку next меняем со значения NULL на значение адреса добавляемого 
объекта node. Переменной tail присваиваем значение node так, чтобы tail указывала на последний элемент списка.

![image](https://user-images.githubusercontent.com/124737857/227741172-bb3f3216-4d38-49c0-8229-a05522968df0.png)

Скорость выполнения этой операции с точки зрения О большого составляет O(1).

Давайте теперь посмотрим, как выполняется добавление элемента в начало односвязного списка. Пусть у нас имеются три элемента. На первый, по-прежнему, ссылается
переменная head, а на последний – переменная tail:

![image](https://user-images.githubusercontent.com/124737857/227741203-666c0b79-a4a2-407d-b7f9-3c7278a09c75.png)

Вначале также создаем новый объект, на который ссылается временная переменная node. Затем, значение ссылки next добавляемого элемента приравниваем значению head – адресу
первого элемента списка, после чего head становится вторым. Поэтому присваиваем его значению переменной node так, чтобы head ссылалась на первый элемент списка:

![image](https://user-images.githubusercontent.com/124737857/227741245-ce23d3c3-cedd-4272-8ca3-52dcc15a18a5.png)

Скорость выполнения этой операции также O(1).

### Доступ к произвольному элементу односвязного списка

Предположим, у нас имеется список из четырех объектов:

![image](https://user-images.githubusercontent.com/124737857/227741273-f04a7534-ac74-4a0f-9104-f8cb6a8cf006.png)

Очевидно, для получения доступа к данным первого или последнего элемента достаточно воспользоваться ссылками head и tail. Например:

head.data – доступ к данным первого элемента

tail.data – доступ к данным последнего элемента

Но как нам обратиться ко 2-му или 3-му элементу этого списка? Для этого придется по цепочке двигаться от первого элемента до заданного k-го элемента, используя 
ссылки next. Обычно для этого создают временную переменную (ссылку на объект), допустим, с именем node. Изначально node равен head, то есть, ссылается на первый
элемент. Чтобы перейти к следующему элементу нужно node присвоить адрес следующего объекта. А этот адрес хранится в переменной next текущего объекта. То 
есть, нам нужно выполнить команду:

```python
node = node.next
```

И указатель node будет ссылаться на второй элемент односвязного списка. Далее, можем действовать по циклу, перебирая все элементы от начала и до конца, пока значение
next не будет равно NULL (или любому другому терминальному значению). Это значит, для доступа к произвольному k-му элементу, мы должны последовательно перебрать 
все предыдущие элементы. В итоге, сложность этой операции с точки зрения О большого, составляет O(n), где n – общее число элементов в односвязном списке.

### Вставка элемента в односвязный список

Нужно вставить пятый новый элемент после второго.

![image](https://user-images.githubusercontent.com/124737857/227741427-7b44f75f-2d22-4dd5-bfee-877f466d98d0.png)

Нам здесь понадобятся ссылки left и right на предыдущий и следующий элементы относительно добавляемого. Чтоб их получить, перебираем все элементы с самого начала 
и фиксируем два соседних, между которыми вставляется новый объект. Далее, создаем новый элемент в памяти компьютера, на который ссылается временная переменная node.
Осталось только настроить связи ссылок next у объектов left и node:

```python
left.next = node
node.next = right
```

Все, новый объект вставлен в односвязный список. В общем случае для этого требуется O(n) операций. 

Однако если эти ссылки у нас уже есть, то сама операция вставки занимает время O(1). Поэтому сложность зависит от конкретного использования односвязного списка. 

### Удаление элементов из односвязного списка

В списке пять элементов и нужно удалить объект node:

![image](https://user-images.githubusercontent.com/124737857/227741746-7cbfb1aa-59f7-411c-81c0-3be381271398.png)

Для этого достаточно у предыдущего объекта left переопределить ссылку next на объект right:

```python
left.next = right
```

и освободить память, занимаемую объектом node:

![image](https://user-images.githubusercontent.com/124737857/227741808-1d97a4a8-fdba-4bff-80e6-eb4840e2fced.png)

Скорость самой операции удаления элемента node из односвязного списка выполняется за константное время O(1). Но для получения ссылок left и right требуется O(n) 
операций. Поэтому, в общем случае, имеем объем вычислений, равный O(n), где n – число элементов в списке.

**Удаление первого и последнего элементов односвязного списка.**

Первый элемент удаляется относительно просто. Нам достаточно переместить указатель head на следующий элемент и освободить память, занимаемую элементом node:

![image](https://user-images.githubusercontent.com/124737857/227741860-e5408c0b-c0f1-435a-a79e-dfe58537af72.png)

Скорость этой операции с точки зрения О большого O(1).

При удалении последнего элемента в односвязном списке нам необходимо сначала получить ссылку на предпоследний элемент, затем, освободить память последнего элемента 
tail. Изменить значение tail на node:

```python
tail = node
```

и поменять значение ссылки next объекта node на NULL:

```python
node.next = NULL
```

Скорость удаления самого элемента составляет O(1), но переход к предпоследнему элементу O(n). Поэтому общая вычислительная сложность этого алгоритма составляет O(n).

|               | Команда | Big O |
| ------------- | ------------- | ------------ |
| Добавление в начало  | push_front() | O(1) |
| Добавление в конец  | push_back() | O(1) |
| Удаление с конца  | pop_back() | O(n) |
| Удаление с начала  | pop_front() | O(1) |
| Вставка элемента  | insert() | O(n) |
| Удаление промежуточных элементов  | erase() | O(n) |
| Доступ к элементу  | iterator | O(n) |

### Задания

1. Отметьте все верные утверждения для односвязного списка.

![image](https://user-images.githubusercontent.com/124737857/227742278-f59f5334-3fe9-4d1d-bde8-3efbd1b4311a.png)

![image](https://user-images.githubusercontent.com/124737857/227742306-96f84f2a-f48c-4122-8bec-dfc235ad6905.png)

2. Пусть на первый объект односвязного списка ссылается указатель head. Каждый объект списка имеет указатель next на следующий элемент. Предположим, что в списке 
10 элементов. Выберите наборы команд (написанные на языке Python), которые позволяют перейти к 4-му элементу этого списка.

![image](https://user-images.githubusercontent.com/124737857/227742396-4ccb0e03-b119-4028-b219-4582d1997ff1.png)

3. Отметьте все преимущества односвязных список перед массивами.

![image](https://user-images.githubusercontent.com/124737857/227742433-ba2a08f3-c68c-4980-b7a1-8c2169aeedc9.png)

4. Какой из набора команд (на языке Python) выполняет добавление нового элемента: 

```python
ptr = Node()
```

в начало односвязного списка, на который имеются ссылки head (на первый элемент) и tail (на последний элемент). Каждый объект односвязного списка имеет ссылку next
на следующий элемент, а если его нет, то на значение NULL (либо None для Python).

Здесь полагается, что в односвязном списке имеется хотя бы один элемент.

![image](https://user-images.githubusercontent.com/124737857/227742571-757cfdb6-40fe-498e-8633-dc73497f2054.png)

5. Какой из набора команд (на языке Python) выполняет добавление нового элемента: 

```python
ptr = Node()
```

в конец односвязного списка, на который имеются ссылки head (на первый элемент) и tail (на последний элемент). Каждый объект односвязного списка имеет ссылку next
на следующий элемент, а если его нет, то на значение NULL (либо None для Python).

Здесь полагается, что в односвязном списке имеется хотя бы один элемент.

![image](https://user-images.githubusercontent.com/124737857/227742709-044e4285-a09d-42e2-8ce5-1d9d570b9821.png)

6. Какой из набора команд (на языке Python) выполняет удаление элемента с конца односвязного списка, на который имеются ссылки:

 - head - на первый элемент;
 - ptr - на предпоследний элемент;
 - tail - на последний элемент. 

Каждый объект односвязного списка имеет ссылку next на следующий элемент, а если его нет, то на значение NULL (либо None для Python). 

Здесь полагается, что в односвязном списке имеются хотя бы два элемента.

![image](https://user-images.githubusercontent.com/124737857/227742883-e0b359fb-ff8e-4925-addb-fb8dc071716d.png)

7. Какой из набора команд (на языке Python) выполняет удаление элемента с начала односвязного списка, на который имеются ссылки:

 - head - на первый элемент;
 - tail - на последний элемент. 
 - 
Каждый объект односвязного списка имеет ссылку next на следующий элемент, а если его нет, то на значение NULL (либо None для Python). 

Здесь полагается, что в односвязном списке имеются хотя бы два элемента.

![image](https://user-images.githubusercontent.com/124737857/227742944-651b1fe1-0987-4bc9-af82-ab4413fe34e3.png)

![image](https://user-images.githubusercontent.com/124737857/227742984-c92b1993-8eef-4787-b265-207d26b84028.png)
