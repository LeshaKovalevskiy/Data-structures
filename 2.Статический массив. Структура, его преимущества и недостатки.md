## Статический массив. Структура, его преимущества и недостатки

Первый важный момент. Все элементы статического массива должны иметь единый тип данных. Например, только целые числа, или только вещественные числа, или только 
символы и так далее. Не предполагается в одном и том же массиве сохранять разные типы данных.

![image](https://user-images.githubusercontent.com/124737857/227613892-fa37fd88-13ef-497f-9f21-4294628b5c7d.png)

Второй важный момент. Длина статического массива (то есть, число его элементов) задается фиксированным значением и не меняется.

![image](https://user-images.githubusercontent.com/124737857/227613934-9391a550-4f1e-4aae-a5bd-86d9c883bb88.png)

Третий важный момент: последовательное распределение элементов статического массива в памяти компьютера. То есть, все элементы статического массива располагаются 
строго друг за другом (без каких-либо пропусков), начиная с некоторого начального адреса (номера ячейки памяти).

Например(массив элементов типа int):

![image](https://user-images.githubusercontent.com/124737857/227614428-484c642b-9c9f-4874-a832-c7aa2207e6ff.png)

Мы здесь полагаем, что массив располагается с 1000-й ячейки в памяти компьютера и занимает: size = n ∙ 4 байт

В общем случае, если обозначить через k размер одного элемента в памяти, то выражение примет более общий вид: size = n ∙ k байт

### Доступ к отдельным элементам статического массива

Например, если имя массива ar, то в языках программирования, этот ar, как правило, есть не что иное, как ссылка на первый элемент массива. То есть, в данном 
случае ссылка ar хранит адрес 1000 и через него работает с представленным массивом.

Итак, зная начальный адрес массива ar и размер каждого его элемента k, мы легко можем обратиться к первому элементу. 
Это ar + 0 ∙ k

Для доступа ко второму элементу нам нужно сместиться на k байт, то есть, второй элемент хранится по адресу: ar + 1 ∙ k

И так далее для произвольного i-го: ar + (i – 1) ∙ k

Как правило, операция доступа к отдельному элементу массива, в языках программирования записывается по следующему синтаксису:

- при считывании значения(value = ar[j])

- при записи значения(ar[j] = value)

То есть, пишется имя массива и затем в квадратных скобках указывается индекс элемента, к которому идет обращение. Очевидно, здесь мы имеем константное время 
выполнения операций считывания и записи значений, а значит, в терминах О большого их сложность составляет: O(1)

И это главное преимущество данной структуры. Она обеспечивает мгновенный доступ к любому элементу.

### Добавление элементов в массив

Начнем с операции вставки. Допустим, мы определили массив длиной в 10 элементов, но записали в него только первые шесть значений:

![image](https://user-images.githubusercontent.com/124737857/227616945-3deb2833-e5b2-42fc-9936-9082041b5e41.png)

Если нам нужно добавить следующее седьмое значение, то делается это элементарно: ar[6] = 7

Но, если вставить нужно не в конец, а, например, в начало этого массива, то придется сначала сдвинуть все элементы вправо:

![image](https://user-images.githubusercontent.com/124737857/227617052-f3ef2eb5-590c-48be-9287-48981d1897a6.png)

А, затем, первому элементу присвоить новое значение: ar[0] = 0

В общем случае нужно будет сдвинуть все n элементов этого массива для вставки нового. То есть, сложность составляет: O(n)

### Удаление элементов из массива

По аналогии выполняется операция удаления элементов из массива. Опять же, если нам нужно избавиться от какого-либо последнего элемента, то это можно сделать очень
быстро, достаточно уменьшить счетчик его актуальных значений:

![image](https://user-images.githubusercontent.com/124737857/227617212-b100846b-d09e-4348-988d-8bc4ecfc7044.png)

Счетчик k мы вводим в программе сами и он работает совместно, но независимо от массива. То есть, при удалении одного значения мы его уменьшаем на 1, а при добавлении
одного элемента – увеличиваем на 1. В результате знаем, сколько в массиве актуальных значений, которые содержат информационные данные. При этом сами значения 
всегда должны следовать с самого начала.

А что если удалить нужно самый первый? Тогда придется сдвинуть все остальные элементы влево:

![image](https://user-images.githubusercontent.com/124737857/227617326-86028dbe-aa50-4fcf-8533-c4d49e74a350.png)

В общем случае объем вычислений с точки зрения О большого также будет составлять: O(n)

Таблица вычислительной сложности для статического массива:

|||
| ------------- | ------------- |
| запись  | O(1) |
| чтение  | O(1) |
| вставка  | O(n) |
| удаление  | O(n) |

### Преимущества и недостатки статического массива

**Достоинства статического массива:**
 - Скорость доступа к произвольному элементу O(1) для записи или чтения значения.
 - Просто реализуется и удобен для небольших наборов данных.

**Недостатки статического массива:**
 - Хранение данных выполняется в непрерывной области памяти. Не всегда эффективно для очень больших объемов данных.
 - Статический массив не может менять число своих элементов в процессе работы программы. Если зарезервированного места окажется недостаточно, то данные могут 
 - потеряться.
 - Вставка и удаление элементов выполняется за время O(n). Может быть критично при больших n.

### Задания из курса

1. Что из себя представляет статический массив?

![image](https://user-images.githubusercontent.com/124737857/227619753-91d35aa9-76ce-4adc-aa91-fbbe443095cf.png)

2. Пусть имеется следующий статический массив, который хранит целые значения:

![image](https://user-images.githubusercontent.com/124737857/227619843-3dae9243-b830-4382-ab77-3ade182e88a2.png)

Каждый элемент этого массива занимает 4 байта памяти. Сколько байт занимает весь массив? 

![image](https://user-images.githubusercontent.com/124737857/227619908-408492c4-64ae-409a-9242-351feed468da.png)

3. Пусть некоторый статический массив с именем ar_d хранит наборы чисел:

```python
ar_d = [1, 2, -5, 0, 100, 1, 5, 20]
```

Выберите правильный вариант записи оператора для обращения к числу 100 этого массива.

![image](https://user-images.githubusercontent.com/124737857/227620211-4dd4b06c-9192-4b7e-b10b-38394847ab97.png)

4. Пусть имеется следующий статический массив с именем ar_s, который хранит строку:

```python
ar_s = "Структуры данных"
```

Какому символу соответствует адрес: ar_s + 7

![image](https://user-images.githubusercontent.com/124737857/227620605-aedccf08-37a1-41d5-b42e-8ff30a8679c3.png)

5.  Какова вычислительная сложность операции вставки нового значения в произвольную позицию статического массива размера n (при условии, что места для записи 
значения в массиве достаточно)?

![image](https://user-images.githubusercontent.com/124737857/227620749-db8120a3-ecb0-427e-aff6-6f459217a623.png)

6. Какова вычислительная сложность операции удаления произвольного значения статического массива размера n?

![image](https://user-images.githubusercontent.com/124737857/227620957-05ac1469-375d-4f2f-a9f9-ee8cba458a0e.png)

7. Пусть имеется следующий статический массив с именем ar_s, который хранит отдельные символы:

![image](https://user-images.githubusercontent.com/124737857/227621204-e7f05c33-81d5-4fc1-aa6d-b55dc479a5d8.png)

Каждый элемент этого массива занимает 1 байт памяти. Пусть адрес первого элемента массива равен 1000 (то есть, ar_s равен 1000). Какой адрес будет у символа 
буквы 'и'?

![image](https://user-images.githubusercontent.com/124737857/227621262-94abd808-e56f-4a6c-ae7c-9d473424dc6a.png)
